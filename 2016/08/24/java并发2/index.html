
 <!DOCTYPE HTML>
<html >
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  
    <title>Java并发编程实战--笔记 | SamanthaChen&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="陈希蔓">
    

    
    <meta name="description" content="概述进程的通信：套接字，信号处理器，共享内存，信号量，文件
线程安全性线程安全: 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现成正确的行为，那么就称这个类时线程安全的。
无状态对象一定是线程安全的。无状态对象值的是：既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程实战--笔记">
<meta property="og:url" content="http://yoursite.com/2016/08/24/java并发2/index.html">
<meta property="og:site_name" content="SamanthaChen's Blog">
<meta property="og:description" content="概述进程的通信：套接字，信号处理器，共享内存，信号量，文件
线程安全性线程安全: 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现成正确的行为，那么就称这个类时线程安全的。
无状态对象一定是线程安全的。无状态对象值的是：既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的">
<meta property="og:updated_time" content="2016-09-04T13:52:46.540Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发编程实战--笔记">
<meta name="twitter:description" content="概述进程的通信：套接字，信号处理器，共享内存，信号量，文件
线程安全性线程安全: 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现成正确的行为，那么就称这个类时线程安全的。
无状态对象一定是线程安全的。无状态对象值的是：既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的">

    
    <link rel="alternative" href="/atom.xml" title="SamanthaChen&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="SamanthaChen&#39;s Blog" title="SamanthaChen&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="SamanthaChen&#39;s Blog">SamanthaChen&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
						<form class="search" action="https://samanthachen.github.io/" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 2073345143534261000 ><input type="text" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/24/java并发2/" title="Java并发编程实战--笔记" itemprop="url">Java并发编程实战--笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="陈希蔓" target="_blank" itemprop="author">陈希蔓</a>
		
  <p class="article-time">
    <time datetime="2016-08-24T00:30:59.849Z" itemprop="datePublished"> 发表于 2016-08-24</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程安全性"><span class="toc-number">2.</span> <span class="toc-text">线程安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原子性"><span class="toc-number">2.1.</span> <span class="toc-text">原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#竞态条件"><span class="toc-number">2.1.1.</span> <span class="toc-text">竞态条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟初始化中的竞态条件"><span class="toc-number">2.1.2.</span> <span class="toc-text">延迟初始化中的竞态条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合操作"><span class="toc-number">2.1.3.</span> <span class="toc-text">复合操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加锁机制"><span class="toc-number">2.2.</span> <span class="toc-text">加锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内置锁"><span class="toc-number">2.2.1.</span> <span class="toc-text">内置锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重入"><span class="toc-number">2.2.2.</span> <span class="toc-text">重入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用锁来保护状态"><span class="toc-number">2.3.</span> <span class="toc-text">用锁来保护状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#活跃性与性能"><span class="toc-number">2.3.1.</span> <span class="toc-text">活跃性与性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象的共享"><span class="toc-number">3.</span> <span class="toc-text">对象的共享</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#可见性"><span class="toc-number">3.1.</span> <span class="toc-text">可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#失效数据"><span class="toc-number">3.1.1.</span> <span class="toc-text">失效数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非原子的64位操作"><span class="toc-number">3.1.2.</span> <span class="toc-text">非原子的64位操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加锁与可见性"><span class="toc-number">3.1.3.</span> <span class="toc-text">加锁与可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile变量"><span class="toc-number">3.1.4.</span> <span class="toc-text">Volatile变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发布与溢出"><span class="toc-number">3.2.</span> <span class="toc-text">发布与溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程封闭"><span class="toc-number">3.3.</span> <span class="toc-text">线程封闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ad-hoc线程封闭"><span class="toc-number">3.3.1.</span> <span class="toc-text">Ad-hoc线程封闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈封闭"><span class="toc-number">3.3.2.</span> <span class="toc-text">栈封闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal类"><span class="toc-number">3.3.3.</span> <span class="toc-text">ThreadLocal类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不变性"><span class="toc-number">3.4.</span> <span class="toc-text">不变性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final域"><span class="toc-number">3.4.1.</span> <span class="toc-text">final域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例：使用Volatile类型来发布不可变对象"><span class="toc-number">3.4.2.</span> <span class="toc-text">示例：使用Volatile类型来发布不可变对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安全发布"><span class="toc-number">3.5.</span> <span class="toc-text">安全发布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不正确的发布：正确的对象被破坏"><span class="toc-number">3.5.1.</span> <span class="toc-text">不正确的发布：正确的对象被破坏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不可变对象与初始化安全性"><span class="toc-number">3.5.2.</span> <span class="toc-text">不可变对象与初始化安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全发布的常用模式"><span class="toc-number">3.5.3.</span> <span class="toc-text">安全发布的常用模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事实不可变对象"><span class="toc-number">3.5.4.</span> <span class="toc-text">事实不可变对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可变对象"><span class="toc-number">3.5.5.</span> <span class="toc-text">可变对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全地共享对象"><span class="toc-number">3.5.6.</span> <span class="toc-text">安全地共享对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象的组合"><span class="toc-number">4.</span> <span class="toc-text">对象的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#设计线程安全的类"><span class="toc-number">4.1.</span> <span class="toc-text">设计线程安全的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#收集同步需求"><span class="toc-number">4.1.1.</span> <span class="toc-text">收集同步需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖状态的操作"><span class="toc-number">4.1.2.</span> <span class="toc-text">依赖状态的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态的所有权"><span class="toc-number">4.1.3.</span> <span class="toc-text">状态的所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例封闭"><span class="toc-number">4.1.4.</span> <span class="toc-text">实例封闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java监听器模式"><span class="toc-number">4.1.5.</span> <span class="toc-text">java监听器模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全性的委托"><span class="toc-number">4.2.</span> <span class="toc-text">线程安全性的委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#委托失效时"><span class="toc-number">4.2.1.</span> <span class="toc-text">委托失效时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发布底层的状态变量"><span class="toc-number">4.2.2.</span> <span class="toc-text">发布底层的状态变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#现有的线程安全类中添加功能"><span class="toc-number">4.3.</span> <span class="toc-text">现有的线程安全类中添加功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端加锁机制"><span class="toc-number">4.3.1.</span> <span class="toc-text">客户端加锁机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将同步策略文档化"><span class="toc-number">4.4.</span> <span class="toc-text">将同步策略文档化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础构建模块"><span class="toc-number">5.</span> <span class="toc-text">基础构建模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#同步容器类"><span class="toc-number">5.1.</span> <span class="toc-text">同步容器类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步容器类的问题"><span class="toc-number">5.2.</span> <span class="toc-text">同步容器类的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器与ConcurrentModificationExpection"><span class="toc-number">5.2.1.</span> <span class="toc-text">迭代器与ConcurrentModificationExpection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐藏迭代器"><span class="toc-number">5.2.2.</span> <span class="toc-text">隐藏迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发容器"><span class="toc-number">5.3.</span> <span class="toc-text">并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">5.3.1.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#额外的原子map操作"><span class="toc-number">5.3.2.</span> <span class="toc-text">额外的原子map操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">5.3.3.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞队列和生产者消费者模式"><span class="toc-number">5.4.</span> <span class="toc-text">阻塞队列和生产者消费者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#串行线程封闭"><span class="toc-number">5.4.1.</span> <span class="toc-text">串行线程封闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双端队列与工作密取"><span class="toc-number">5.5.</span> <span class="toc-text">双端队列与工作密取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞方法与中断方法"><span class="toc-number">5.6.</span> <span class="toc-text">阻塞方法与中断方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步工具类"><span class="toc-number">5.7.</span> <span class="toc-text">同步工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#闭锁"><span class="toc-number">5.7.1.</span> <span class="toc-text">闭锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask"><span class="toc-number">5.7.2.</span> <span class="toc-text">FutureTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量"><span class="toc-number">5.7.3.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栅栏"><span class="toc-number">5.7.4.</span> <span class="toc-text">栅栏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建高效且可伸缩的结果缓存"><span class="toc-number">5.8.</span> <span class="toc-text">构建高效且可伸缩的结果缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第一部分小结"><span class="toc-number">5.9.</span> <span class="toc-text">第一部分小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二部分-机构化并发应用程序"><span class="toc-number">6.</span> <span class="toc-text">第二部分 机构化并发应用程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#任务执行"><span class="toc-number">7.</span> <span class="toc-text">任务执行</span></a></li></ol>
		
		</div>
		
		<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>进程的通信：套接字，信号处理器，共享内存，信号量，文件</p>
<h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p>线程安全: 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现成正确的行为，那么就称这个类时线程安全的。</p>
<p>无状态对象一定是线程安全的。<br>无状态对象值的是：既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B的时候，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作时指对于访问同一个状态的所有操作（包括操作本身）来说，这个操作是以原子方式执行的。</p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p>当某个计算的正确性取决于多个线程的而交替执行时序时，就会发生竞态条件。<br>最常见的竞态条件类型是“先检查后执行”操作，即通过一个可能失效的观测结果来决定下一步的动作。</p>
<h3 id="延迟初始化中的竞态条件"><a href="#延迟初始化中的竞态条件" class="headerlink" title="延迟初始化中的竞态条件"></a>延迟初始化中的竞态条件</h3><p>延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。<br>与大多数并发错误一样，竞态条件并不总是会产生错误，还需要某种不恰当的执行时序。然而，竞态条件也可能导致严重的问题。</p>
<h3 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h3><p>“先检查后执行”与“读取-修改-写入”都是复合操作。<br>加锁机制是java确保原子性的内置机制。还有一种方法是使用现有的线程安全类。如java.util.concurrent.atomic中的原子变量类。<br>例如用AtomicLong代替long作为计数器。</p>
<h2 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h2><p>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</p>
<h3 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h3><p>java提供一种内置的锁机制来支持原子性：同步代码块(Synchronized Block)。同步代码块包括两个部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中同步代码块的锁就是方法所调用的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">    <span class="comment">//访问或修改由锁保护的共享状态</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个java对象都可以用作一个实现同步的锁，这些锁被称为内置锁(Intrinsic Lock)或者监视器锁(Monitor Lock)。线程进入同步代码块之前会自动获得锁，退出时自定释放。java的内置锁相当于互斥锁，最多一个线程可以持有。<br>但是这种方法会涉及性能问题。</p>
<h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h3><p>某个线程请求由其他线程持有的锁时候发出请求的线程就会阻塞。但是某个线程试图获得一个已经由自己持有的锁，请求会成功，即“重入”。<br>重入的一种实现方法是为每个锁关联一个获取计数值和一个所有者线程，当计数值为0，这个锁就被认为不被任何线程持有，同一个线程请求一次，计数值减1。<br>某种程度上避免了自己请求自己出现死锁的问题。</p>
<h2 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h2><p>锁能使保护的路径代码以串行形式来访问，可以实现对共享状态的独占访问。<br>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称变量是由这个锁保护的。<br>对象的内置锁与其状态之间并没有内在的关联。虽然大多数类都将内置锁用作一种有效的加锁机制，但对象的域并不一定要通过内置锁来保护。当获取与对象关联的锁时，并不能阻止其他线程访问该对象，某个线程在获得对象的锁之后只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，是为了免去显示地创建锁对象。你需要自行构造加锁协议或者同步策略来实现对共享状态的安全访问，并且在程序中自始至终的使用它们。</p>
<p>每个方法采用同步并不能保证线程安全，因为原子操作之间可能还是存在竞态条件，此外还可能导致活跃性问题(Liveness)或者性能问题(Performance).</p>
<h3 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h3><p>通过缩小同步代码块的作用范围可以容易做到既确保并发性又维护线程安全性。要确保同步代码块不能过小，并且不要将本来是原子的操作拆分到多个代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行中，其他线程可以访问共享状态。</p>
<p>要判断同步代码块的合理大小，需要在各种设计需求与性能之间进行权衡。包括安全性（这个需求必须得到满足）、简单性和性能。有时候，在简单性与性能之间会发生冲突，但通常能平衡。</p>
<p>另外加锁时间过长可能带来活跃性和性能问题。</p>
<h1 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h1><p>同步和共享和发布对象形成了构建线程安全类以及通过java.util.concurrent类库来构建并发应用程序的重要基础。<br>同步代码块和同步方法可以确保以原子的方式执行操作，但是一种常见的误区是认为关键字synchronized只能用于实现原子性或者确定“临界区（Critical Section）”。同步还有另一个重要方面：没存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同步修改该状态，并且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变换。如果没有同步就无法实现，可以通过显式的同步或者类库中的内置同步来保证对象被安全的发布。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>在没有同步的情况下，编译器处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。</p>
<h3 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h3><p>get和set操作都必须实现同步。否则get可能取得失效值。</p>
<h3 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h3><p>当线程在没有同步的情况下读取变量，可能会得到一个失效值，但至少这个值是由之前的某个线程设置的值，而不是一个随机值。这种安全性保证也被称作最低安全性(out-of-the-air-safty)。<br>最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量double和long。java内存模型要求，变量的读取和操作和写入都必须是原子操作，但是对于非volatile的long和double变量，jvm允许将64位的读写操作分解为两个32位的操作。<br>多线程使用long double需要关键字volatile或者锁。</p>
<h3 id="加锁与可见性"><a href="#加锁与可见性" class="headerlink" title="加锁与可见性"></a>加锁与可见性</h3><p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有的线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
<h3 id="Volatile变量"><a href="#Volatile变量" class="headerlink" title="Volatile变量"></a>Volatile变量</h3><p>稍弱的同步机制，确保将变量的更新操作通知到其他线程。把变量声明为volatile类型后，编译器与运行时都会注意到这个变量时共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者其他对处理器不可见的地方，因此在读取volatile变量时总会返回最新写入的值。<br>访问volatile变量时不会执行加锁操作，也不会执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</p>
<p>写入volatile变量相当于退出同步代码块，读取volatile变量相当于进入同步代码块，但是不能过度依赖volatile。</p>
<p>仅当volatile变量能简化代码的实现以及对同步策略的验证时，才能使用它们。如果在验证争取性时需要对可见性进行复杂判断，那么就不要使用volatile变量。volatile变量的正确性使用包括：确保自身状态的可见性，确保所引用对象的状态的可见性以及标志一些重要程序生命周期时间的发生（如初始化或者关闭）。</p>
<blockquote>
<p>加锁机制能确保可见性和原子性，而volatile变量只能确保可见性。</p>
</blockquote>
<p>例如自增操作的原子性volatile不能保证。<br>当且仅当满足以下所有条件是，才应该使用volatile变量;</p>
<ul>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中</li>
<li>在访问变量时不需要加锁</li>
</ul>
<h2 id="发布与溢出"><a href="#发布与溢出" class="headerlink" title="发布与溢出"></a>发布与溢出</h2><p>发布publish一个对象的意思是，使对象能够在当前作用域之外的代码中使用。<br>例如：</p>
<ul>
<li>将一个对象的引用保存早其他代码可以访问的地方</li>
<li>在某一个非私有的方法中返回该引用</li>
<li>将引用传递到其他类的方法中</li>
<li>发布一个内部的类实例<br>当某个不该发布的对象被发布的时候称为逸出escape。</li>
</ul>
<p>内部类的this引用会在构造函数中逸出。当内部类实例发布的时候，在外部封装的类实例也逸出了。当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。</p>
<blockquote>
<p>不要在构造过程中使用this引用逸出</p>
</blockquote>
<p>在构造过程中使用this引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程的时候，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或者runnable是该对象的而一个内部类） this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见他。在构造函数中创建线程最好不要立即启动，而是通过一个start或者initialize方法来启动。在构造函数中调用一个可改写的实例方法（既不是私有也不是final）同样会导致this引用在构造过程中溢出。</p>
<p>如果香皂构造函数中注册一个事件监听器或者启动线程，可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程。</p>
<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>一种避免使用同步的方法就是不共享数据，仅在单线程内访问数据，称作线程封闭。<br>java语言及核心库提供了一些机制来帮助维持线程的封闭性，例如局部变量和ThreadLocal类，但即使突刺，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。</p>
<h3 id="Ad-hoc线程封闭"><a href="#Ad-hoc线程封闭" class="headerlink" title="Ad-hoc线程封闭"></a>Ad-hoc线程封闭</h3><p>ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。<br>非常脆弱，没有任何一种语言特性如可见性修饰符或者局部变量能将对象封闭到目标线程上。通常使用是为特定子系统实现一个单线程子系统。少用，用栈封闭或者ThreadLocal。</p>
<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>线程封闭的特例，只能通过局部变量才能访问对象。</p>
<h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><p>使线程中某个值与保存值的对象关联起来，提供了get与set等访问接口与方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。<br>ThreadLocal对象通常用于防止对可变的单实例变量（singleton）或全局变量进行共享。<br>例如将JDBC的链接保存都ThreadLocak对象中，每个线程都拥有自己的链接。<br>当某个频繁执行的操作需要一个临时对象例如缓冲区而又希望避免在每次执行时都重新分配该临时对象就可以使用这项技术。<br>假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象，可以维持线程安全性。<br>在实现应用程序框架时大量采用了ThreadLocal。<br>ThreadLocal变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合变量，因此在使用的时候要格外小心。</p>
<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>满足同步需求的另一种方法是使用不可变对象(Immutable Object).</p>
<blockquote>
<p>不可变对象一定是线程安全的</p>
</blockquote>
<p>不可变对象不等于将对象中所有的域都声明为final；类型，即时对象中所有的域都是final类型，这个兑现也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。</p>
<p>不变性条件如下：</p>
<blockquote>
<p>当满足以下条件时，对象才是不可变的：</p>
<pre><code>- 对象创建以后其状态不能修改
- 对象的所有域都是final类型（有特例，如String）
- 对象时正确创建的（即在对象创建期间，this引用没有逸出）
</code></pre></blockquote>
<p>“不可变对象”与“不可变的对象引用”之间存在差异。保存在不可变对象中的程序状态仍然可以更新，即通过一个保存新状态的实例来替换原有的而不可变对象。</p>
<h3 id="final域"><a href="#final域" class="headerlink" title="final域"></a>final域</h3><p>final类型的域是不能求改的，final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时候无需同步。</p>
<blockquote>
<p>正如“除非需要更高的可见性，否则应将所有的域声明为私有域”是一个良好的编程习惯<br>“除非需要某个域是可变的，否则应该将其声明为final域”也是一个良好的编程习惯。</p>
</blockquote>
<h3 id="示例：使用Volatile类型来发布不可变对象"><a href="#示例：使用Volatile类型来发布不可变对象" class="headerlink" title="示例：使用Volatile类型来发布不可变对象"></a>示例：使用Volatile类型来发布不可变对象</h3><p>对于在访问和更新多个相关变量时出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。如果是一个可变对象，那么就必须使用锁来确保原子性。如果是一个不可变对象，那么当线程获得了该对象的引用后，就不必担心另一个线程会修改对象的状态。如果要更新对象，那么可以创建一个新的容器对象，但其他使用原有对象的线程仍然会看到对象处于一致的状态。</p>
<h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><h3 id="不正确的发布：正确的对象被破坏"><a href="#不正确的发布：正确的对象被破坏" class="headerlink" title="不正确的发布：正确的对象被破坏"></a>不正确的发布：正确的对象被破坏</h3><p>不能指望一个尚未被完全创建的对象拥有完整性。某个观察该对象的线程将看到对象处于不一致的状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没修改过。</p>
<h3 id="不可变对象与初始化安全性"><a href="#不可变对象与初始化安全性" class="headerlink" title="不可变对象与初始化安全性"></a>不可变对象与初始化安全性</h3><p>由于不可变对象是一种非常重要的对象，因此java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。<br>为了维持初始化安全性，必须满足不可变性的所有需求：状态不可更改，所有域都是final，正确构造过程。</p>
<blockquote>
<p>任何线程都可以在不需要额外同步的情况下安全的访问不可变对象，即时在发布这些对象时没有同步。</p>
</blockquote>
<p>这种保证还将延伸到正确创建对象中所有的final类型的域。在没有额外同步的情况下，也可以安全的访问final类型的域。然而，如果final类型的与指向的是可变对象，那么在访问这些于所指向的对象的状态时仍需要同步。</p>
<h3 id="安全发布的常用模式"><a href="#安全发布的常用模式" class="headerlink" title="安全发布的常用模式"></a>安全发布的常用模式</h3><p>可变对象必须通过安全的方式来发布，即发布和使用该对象的线程时都必须使用同步。</p>
<blockquote>
<p>要安全的发布一个对象，对象的引用以及对象的状态必须同时对其他线程课件。一个正确构造的对象可以通过以下方式来安全地发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到volatile类型的域或者AtomicReference对象中</li>
<li>将对象的引用保存到某个正确构造对象的funal域中</li>
<li>将对象的引用保存到一个由锁保护的域中（或者线程安全容器内部）</li>
</ul>
</blockquote>
<p>将对象放到某个线程安全的容器内部如Vector或者synchronizedList时，满足最后一条需求。线程安全库的容器类提供了以下的安全发布保证：</p>
<ul>
<li>通过将一个键或者值当如到HashTable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。</li>
<li>通过将某个元素放入到Vector、CopyOnWriteArrayList、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的进程。</li>
<li>通过将某个元素放入到BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到人格从这些队列中访问该元素的进程。</li>
<li>类库中其他数据传递机制，如Future和Exchangeer同样能实现安全发布。</li>
</ul>
<p>通常要发布一个讲台构造的对象，最简单安全的方式是使用静态的初始化器：<br>public static Holder holder = new Holder(42);<br>静态初始化器由jvm在类的初始化阶段执行。由于jvm内部存在同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。</p>
<h3 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h3><p>如果对象在发布后不会再改吧，足以保证所有访问都是安全的。<br>如果对象从技术上看是可变的，但其在发布后不会再改变，那么把这种对象称作“事实不可变对象”。</p>
<blockquote>
<p>在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。</p>
</blockquote>
<h3 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h3><p>可变对象必须在发布对象时使用同步，并且在每次对象访问时同样需要使用同步来确保后继修改操作的可见性。</p>
<blockquote>
<p>对象的发布需求取决于它的可变性：</p>
<ul>
<li>不可变对象可以通过任意机制来发布</li>
<li>事实不可变对象必须通过安全方式来发布</li>
<li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。</li>
</ul>
</blockquote>
<h3 id="安全地共享对象"><a href="#安全地共享对象" class="headerlink" title="安全地共享对象"></a>安全地共享对象</h3><p>当发布一个对象时，必须明确的说明对象的访问方式。</p>
<blockquote>
<p>在并发程序使用和共享对象时，可以使用一些实用的策略，如：</p>
<ul>
<li>线程封闭<br>线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个<br>线程修改。</li>
<li>只读共享<br>在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问。但是任何线程<br>都不能修改。共享的对象包括不可变对象和事实不可变对象。</li>
<li>线程安全共享<br>线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口进行访问<br>而不需要进一步的同步。</li>
<li>保护对象<br>被保护的对象只能通过持有特定的锁来访问。保护的对象包括封装在其他线程安全的<br>对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li>
</ul>
</blockquote>
<h1 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h1><h2 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h2><p>尽管可以将程序所有状态保存在公有的静态域，但是与将状态封装的程序相比，安全性更难保证。</p>
<blockquote>
<p>在设计线程安全类的过程中，需要包含以下三个基本要素：</p>
<ul>
<li>找出构成对象状态的所有变量</li>
<li>找出约束状态变量的不变性条件</li>
<li>建立对象状态的并发访问管理策略</li>
</ul>
</blockquote>
<p>同步策略定义了如何在不违背对象不变条件或者后验条件的情况下对其状态访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来维护线程安全性，并且规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析和维护，必须将同步策略写为正式文档。</p>
<h3 id="收集同步需求"><a href="#收集同步需求" class="headerlink" title="收集同步需求"></a>收集同步需求</h3><p>不可变条件判断状态是有效的还是无效的。<br>后延条件判断状态迁移是否是有效的。<br>由于不可变性条件以及后延条件在状态以及状态转换上施加了各种约束，因此就需要额外的同步与封装。如果这些状态是无效的，那么必须对底层的状态变量进行封装，否则客户代码可能会使对象处于无效状态；<br>如果某个操作中存在无效的状态转换，那么该操作必须是原子的。另外如果类中没有施加这种约束就可以放宽封装性或者序列化等要求，一遍获得更高的灵活性或性能。</p>
<h3 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h3><p>基于状态的先验条件，如删除元素前队列必须处于“非空”。<br>如果某个操作中包含有基于状态的先验条件，那么这个操作就成为依赖状态的操作。</p>
<p>实现某个等待先验条件为真时才执行需要通过现有库中类如阻塞队列或者信号量来实现依赖状态的行为。</p>
<h3 id="状态的所有权"><a href="#状态的所有权" class="headerlink" title="状态的所有权"></a>状态的所有权</h3><p>许多情况下，所有权与封装性总是相互关联的：对象封装它所拥有的状态，反之也成了，即对它封装的状态拥有所有权。状态变量的拥有者可以决定何种加锁协议维护变量状态的完整性。<br>然而发布某个独享的引用就不在拥有独占权，最多是“共享控制权”。<br>容器类通常表现出一种“所有权分离”的形式。其中容器类具有其自身的状态，而客户代码则拥有容器中各个对象的状态。</p>
<h3 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h3><p>封装简化了线程安全类的实现过程，提供了一种实例封闭的机制。</p>
<blockquote>
<p>将数据封装在对象内部，可以将数据的访问限制在对象的方法删，从而更容易确保线程<br>在访问数据的时候总能持有正确的锁。</p>
</blockquote>
<p>被封闭的对象一定不能超过既定的作用域。如对象可以封闭在类的一个实例（作为类的一个私有成员）中，或者封闭在某个作用域内（作为一个局部变量），再或者封闭在线程内（例如单个线程中方法传递而不是多个线程共享对象）。</p>
<p>java的类库中有很多线程封闭的实例。其中有些类的唯一用途就是将非线程安全的类转化为线程安全的列。一些基本的容器是非线程安全的，例如ArrayList和HashMap.。但类库提供了包装工厂方法（例如Collections.synchronizedList及其类似方法）。使得这些非线程安全的类可以在多线程环境中安全的使用。</p>
<p>将本该被封闭对象发布出去会破坏封闭性。</p>
<blockquote>
<p>封闭机制更易于构造线程安全的类，因为放封闭类的状态是，在分析类的线程安全性时就无需检测整个实例。</p>
</blockquote>
<h3 id="java监听器模式"><a href="#java监听器模式" class="headerlink" title="java监听器模式"></a>java监听器模式</h3><p>遵循java监听器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。<br>许多类都使用监听器模式如Vector、HashTable。<br>监听器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都用该锁对象，都可以用来保护对象的状态。</p>
<h2 id="线程安全性的委托"><a href="#线程安全性的委托" class="headerlink" title="线程安全性的委托"></a>线程安全性的委托</h2><p>某些情况下，通过多个线程安全类组合而成的类是线程安全的（各个状态之间不存在耦合关系，彼此独立）；某些情况下，只是一个良好的开端。</p>
<h3 id="委托失效时"><a href="#委托失效时" class="headerlink" title="委托失效时"></a>委托失效时</h3><p>如果某个类有复合操作，仅靠委托是不足以实现线程安全的。在这种情况下，这个类必须提供自己的加锁机制来保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。</p>
<blockquote>
<p>如果一个类是由多个独立且线程安全的状态变量组成，并且在所有操作中都不包含无效的状态转换，那么可以将线程安全性委托给底层的状态变量。</p>
</blockquote>
<h3 id="发布底层的状态变量"><a href="#发布底层的状态变量" class="headerlink" title="发布底层的状态变量"></a>发布底层的状态变量</h3><blockquote>
<p>如果一个状态变量时线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。</p>
</blockquote>
<h2 id="现有的线程安全类中添加功能"><a href="#现有的线程安全类中添加功能" class="headerlink" title="现有的线程安全类中添加功能"></a>现有的线程安全类中添加功能</h2><p>要添加一个新的原子操作，最安全的方法是修改原始的类，但这通常无法做到。因为你可能无法访问或者修改类的源代码。修改的时候还需要理解代码中的同步策略，这样增加的功能才能和原有的设计保持一致。<br>另一种方法是扩展这个类。但是并非所有的类都将状态向子类公开，因此也不合适。</p>
<p>扩展方法比直接添加更脆弱，因为现有的额同步策略实现被分布到多个单独维护的源代码文件中。若底层类改变了同步策略选择不同的锁，子类会被破坏。</p>
<h3 id="客户端加锁机制"><a href="#客户端加锁机制" class="headerlink" title="客户端加锁机制"></a>客户端加锁机制</h3><p>第三种策略是扩展类的功能，但并不扩展类本身，而是将扩展代码放入一个“辅助类”中。</p>
<h2 id="将同步策略文档化"><a href="#将同步策略文档化" class="headerlink" title="将同步策略文档化"></a>将同步策略文档化</h2><blockquote>
<p>在文档总说明了客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。</p>
</blockquote>
<h1 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h1><h2 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h2><p>Vector和HashTable，这些同步的封装是由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个共有方法都进行同步，使得每次只有一个线程能访问容器的状态。</p>
<h2 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h2><p>同步容器类都是线程安全的，但是在某些情况下需要额外的客户端加锁来保护复合操作。<br>常见的复合操作：</p>
<ul>
<li>迭代（反复访问元素，知道遍历完容器中所有元素）</li>
<li>跳转（根据指定顺序找到当前元素的下一个元素）</li>
<li>条件运算（例如若没有则添加）<br>在同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但是当其他线程并发地修改容器时，可能会表现出意料之外的行为。</li>
</ul>
<h3 id="迭代器与ConcurrentModificationExpection"><a href="#迭代器与ConcurrentModificationExpection" class="headerlink" title="迭代器与ConcurrentModificationExpection"></a>迭代器与ConcurrentModificationExpection</h3><p>迭代器是即时失败的fail-fast，意味着当他们发现容器在迭代过程中被修改的时候就会抛出一个ConcurrentModificationException异常。<br>如果不希望迭代期间对容器加锁，另一种替代方法是克隆容器，并在副本上进行迭代。</p>
<h3 id="隐藏迭代器"><a href="#隐藏迭代器" class="headerlink" title="隐藏迭代器"></a>隐藏迭代器</h3><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><blockquote>
<p>通过并发起来代替同步容器，可以极大地提高伸缩性并降低风险</p>
</blockquote>
<ul>
<li>HashMap： ConcurrentHashMap</li>
<li>List： CopyOnWriteArrayList</li>
<li>Queue：ConcurrentLinkedQueue，BlockingQueue</li>
<li>SortedMap: ConcurrentSkipListMap</li>
<li>SortedSet：ConcurrentSkipListSet</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>采用的是分段锁（Lock Striping）的加锁机制。<br>任意数量的读取线程可以并发的访问Map，执行读取操作的线程和执行写入操作的线程可以并发的访问map，并且一定数量的写入线程可以并发地修改Map。ConcurrentHashMap带来的结果是，在并发环境下将实现更高的吞吐量，而在单线程环境中只损失非常小的性能。</p>
<p>ConcurrentHashMap与其他并发容器一起增强了同步容器类：提供的迭代器不会抛出异常，不需要再迭代过程对容器加锁。返回的迭代器具有弱一致性，并非即时失败。可以容忍并发地修改，当创建迭代器时会遍历已有的元素，并可以（但是不保证）在迭代器被构造后将修改操作反映给容器。<br>但是例如size和isEmpty等返回只能返回估计值。因此这些操作的需求被弱化了，以换取对其他更重要操作的性能优化，包括get、put、containsKey和remove等。</p>
<p>ConcurrentHashMap没有实现对map加锁提供独占访问，但是HashTable和synchronizedMap实现了。但是签字比后者有更多优势更上劣势。只有当引用程序需要加锁Map进行独占访问时候才放弃ConcurrentHashmap。</p>
<h3 id="额外的原子map操作"><a href="#额外的原子map操作" class="headerlink" title="额外的原子map操作"></a>额外的原子map操作</h3><p>“若没有则添加”“若相等则移除”“若相等则替换”都已经实现为原子操作并在ConcurrentMap接口中声明。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>代替同步List，在迭代期间不需要加锁或者复制。（类似的CopyOnWriteSet作用是替代同步Set）。<br>“CopyOnWrite”写入时复制容器的线程安全性在于，只要正确的发布一个事实不可变的对象，那么在访问该对象时候就不再需要进一步的同步。每次修改的时候，都会创建并重新发布一个新的容器副本，从而实现可变性。<br>写入时复制的容器迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步的时候只需要确保数组内容的可见性。<br>显然开销很大，仅当迭代操作远大于修改操作的时候，才使用“写入时复制”。这个准则很好的描述了很多事件通知系统。</p>
<h2 id="阻塞队列和生产者消费者模式"><a href="#阻塞队列和生产者消费者模式" class="headerlink" title="阻塞队列和生产者消费者模式"></a>阻塞队列和生产者消费者模式</h2><p>阻塞队列BlockingQueue提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。如果队列已经满了，那么put方法可以将阻塞直到有空间可用；如果队列为空，那么take方法将会阻塞直到有元素可用。队列可以是有界的也可以是无界的，无界永远不会阻塞。</p>
<p>阻塞队列支持生产者-消费者这种设计模式，这种方式能简化开花，消除生产者和消费者之间的代码依赖性，将生产数据和使用数据解耦来简化工作负载管理。<br>一种最常见的生产者消费者设计模式就是线程池与工作队列的组合，在Executor任务执行框架中采用。</p>
<blockquote>
<p>在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况向变得更加健壮。</p>
</blockquote>
<p>应该尽早通过阻塞队列在设计者构建资源管理机制。如果阻塞队列不能完全符合设计需求，还可以通过信号量来创建其他的阻塞数据结构。</p>
<p>BlockingQueue的实现由LinkedBlockingQueue和ArrayBlockingQueue。分别与LinkedList和ArrayList类似但具有更好并发性能。还有PriorityBlockingQueue和SynchronousQueue。SynchronousQueue不是一个真正队列，不为为队列中元素维护存储空间，维护的是一组线程，这些线程在等待着把元素加入或者移出队列。而且可以直接交付工作。因此put和take会一致阻塞直到另一个线程已经准备好直接交付。<br>仅当有足够多的消费者，并且总是有一个消费者准备好交付的时候才适合同步队列。</p>
<h3 id="串行线程封闭"><a href="#串行线程封闭" class="headerlink" title="串行线程封闭"></a>串行线程封闭</h3><p>java.util.concurrent包含足够同步机制，从而安全的将对象从生产者线程发布到消费者线程。<br>对于可变对象，生产者-消费者与阻塞队列一起，促进了串行线程封闭。<br>对象池利用了串行线程封闭，将对象“借给”一个请求线程。<br>我们也可以用其他发布机制来传递可变对象的所有权，但必须保证只有一个线程能接受被转移的对象。阻塞队列简化了这个操作，除此之外，还可以通过ConcurrentMap原子方法 remoce或者AtomicReference原子方法compareAndSet完成。</p>
<h2 id="双端队列与工作密取"><a href="#双端队列与工作密取" class="headerlink" title="双端队列与工作密取"></a>双端队列与工作密取</h2><p>正如阻塞队列适用于生产者-消费者模型，双端队列适用于工作密取（Work Stealing）.<br>前者所有消费者一个共享队列，后者每个消费者有各自的双端队列。如果一个消费者完成自己队列中全部工作，可以从其他消费者队列末尾秘密的获取工作。<br>工作密取极大较少了竞争，适用于既是生产者又是消费者的问题–当执行某个工作可能产生更多工作的问题。</p>
<h2 id="阻塞方法与中断方法"><a href="#阻塞方法与中断方法" class="headerlink" title="阻塞方法与中断方法"></a>阻塞方法与中断方法</h2><p>等待IO，等待获得锁，等待从Thread.sleep中等都会线程发生阻塞，并通常处于某种阻塞状态（BLOCKED，WAITING或者TIMED_WAITING）。<br>Thread提供interrupt查询线程是否已经中断或者直接中断。<br>抛出InterruptedException异常时候可以传递这个异常或者恢复中断。</p>
<h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><p>阻塞队列不仅能作为保存对象的容器还能协调生产者和消费者等线程之间的控制了。<br>同步工具类是根据自身状态来协调线程的控制流。除了阻塞队列还有信号量Semaphore、栅栏Barrier以及闭锁latch。<br>这些同步工具类都包含一些特定的结构化属性：封装了一些状态，这些状态将决定执行同步工具类的线程还是继续执行还是等待，此外还提供一些方法对状态进行操作，以及另一些方法用于高效等待同步工具类进入预期状态。</p>
<h3 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h3><p>相当于一扇门。</p>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>也可以做闭锁，表示的计算是通过Callable实现。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>用来控制同时访问某个特定资源的数量或者同时执行某个指定操作的数量，还可以实现某种资源池或者对容器施加边界。</p>
<h3 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h3><p>闭锁来启动一组相关的操作后者等待一组相关的操作结束，是一次性对象，一旦进入终止状态就不能被重置。<br>栅栏是所有线程必须同时到达栅栏位置才能继续执行，用于实现一些协议如约定时间集合。</p>
<h2 id="构建高效且可伸缩的结果缓存"><a href="#构建高效且可伸缩的结果缓存" class="headerlink" title="构建高效且可伸缩的结果缓存"></a>构建高效且可伸缩的结果缓存</h2><h2 id="第一部分小结"><a href="#第一部分小结" class="headerlink" title="第一部分小结"></a>第一部分小结</h2><ul>
<li>可变状态是至关重要的。可变状态越少，越容易保证线程安全。</li>
<li>尽量将域声明为final类型，除非需要他们是可变的</li>
<li>不可变对象一定是线程安全的</li>
<li>封装有助于管理复杂性</li>
<li>用锁来保护每个可变变量</li>
<li>保护同一个不变性条件中所有变量时，要使用同一个锁</li>
<li>执行符合操作期间要持有锁</li>
<li>如果多个线程访问一个可变变量时没有同步机制，那么程序会出现问题。</li>
<li>不要故作聪明推断出不需要同步</li>
<li>在设计过程中考虑线程安全，或者在文档中明确指出不是线程安全的</li>
<li>将同步策略文档化</li>
</ul>
<h1 id="第二部分-机构化并发应用程序"><a href="#第二部分-机构化并发应用程序" class="headerlink" title="第二部分 机构化并发应用程序"></a>第二部分 机构化并发应用程序</h1><h1 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h1>  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Interview/">Interview</a><a href="/tags/Java/">Java</a><a href="/tags/Concurrentcy/">Concurrentcy</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/08/24/java并发2/" data-title="Java并发编程实战--笔记 | SamanthaChen&#39;s Blog" data-tsina="1544950963" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/08/25/设计模式/" title="设计模式java">
  <strong>上一篇：</strong><br/>
  <span>
  设计模式java</span>
</a>
</div>


<div class="next">
<a href="/2016/08/22/java并发/"  title="Java并发">
 <strong>下一篇：</strong><br/> 
 <span>Java并发
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/08/24/java并发2/" data-title="Java并发编程实战--笔记" data-url="http://yoursite.com/2016/08/24/java并发2/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程安全性"><span class="toc-number">2.</span> <span class="toc-text">线程安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原子性"><span class="toc-number">2.1.</span> <span class="toc-text">原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#竞态条件"><span class="toc-number">2.1.1.</span> <span class="toc-text">竞态条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟初始化中的竞态条件"><span class="toc-number">2.1.2.</span> <span class="toc-text">延迟初始化中的竞态条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合操作"><span class="toc-number">2.1.3.</span> <span class="toc-text">复合操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加锁机制"><span class="toc-number">2.2.</span> <span class="toc-text">加锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内置锁"><span class="toc-number">2.2.1.</span> <span class="toc-text">内置锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重入"><span class="toc-number">2.2.2.</span> <span class="toc-text">重入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用锁来保护状态"><span class="toc-number">2.3.</span> <span class="toc-text">用锁来保护状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#活跃性与性能"><span class="toc-number">2.3.1.</span> <span class="toc-text">活跃性与性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象的共享"><span class="toc-number">3.</span> <span class="toc-text">对象的共享</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#可见性"><span class="toc-number">3.1.</span> <span class="toc-text">可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#失效数据"><span class="toc-number">3.1.1.</span> <span class="toc-text">失效数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非原子的64位操作"><span class="toc-number">3.1.2.</span> <span class="toc-text">非原子的64位操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加锁与可见性"><span class="toc-number">3.1.3.</span> <span class="toc-text">加锁与可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile变量"><span class="toc-number">3.1.4.</span> <span class="toc-text">Volatile变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发布与溢出"><span class="toc-number">3.2.</span> <span class="toc-text">发布与溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程封闭"><span class="toc-number">3.3.</span> <span class="toc-text">线程封闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ad-hoc线程封闭"><span class="toc-number">3.3.1.</span> <span class="toc-text">Ad-hoc线程封闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈封闭"><span class="toc-number">3.3.2.</span> <span class="toc-text">栈封闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal类"><span class="toc-number">3.3.3.</span> <span class="toc-text">ThreadLocal类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不变性"><span class="toc-number">3.4.</span> <span class="toc-text">不变性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final域"><span class="toc-number">3.4.1.</span> <span class="toc-text">final域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例：使用Volatile类型来发布不可变对象"><span class="toc-number">3.4.2.</span> <span class="toc-text">示例：使用Volatile类型来发布不可变对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安全发布"><span class="toc-number">3.5.</span> <span class="toc-text">安全发布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不正确的发布：正确的对象被破坏"><span class="toc-number">3.5.1.</span> <span class="toc-text">不正确的发布：正确的对象被破坏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不可变对象与初始化安全性"><span class="toc-number">3.5.2.</span> <span class="toc-text">不可变对象与初始化安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全发布的常用模式"><span class="toc-number">3.5.3.</span> <span class="toc-text">安全发布的常用模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事实不可变对象"><span class="toc-number">3.5.4.</span> <span class="toc-text">事实不可变对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可变对象"><span class="toc-number">3.5.5.</span> <span class="toc-text">可变对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全地共享对象"><span class="toc-number">3.5.6.</span> <span class="toc-text">安全地共享对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象的组合"><span class="toc-number">4.</span> <span class="toc-text">对象的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#设计线程安全的类"><span class="toc-number">4.1.</span> <span class="toc-text">设计线程安全的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#收集同步需求"><span class="toc-number">4.1.1.</span> <span class="toc-text">收集同步需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖状态的操作"><span class="toc-number">4.1.2.</span> <span class="toc-text">依赖状态的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态的所有权"><span class="toc-number">4.1.3.</span> <span class="toc-text">状态的所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例封闭"><span class="toc-number">4.1.4.</span> <span class="toc-text">实例封闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java监听器模式"><span class="toc-number">4.1.5.</span> <span class="toc-text">java监听器模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全性的委托"><span class="toc-number">4.2.</span> <span class="toc-text">线程安全性的委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#委托失效时"><span class="toc-number">4.2.1.</span> <span class="toc-text">委托失效时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发布底层的状态变量"><span class="toc-number">4.2.2.</span> <span class="toc-text">发布底层的状态变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#现有的线程安全类中添加功能"><span class="toc-number">4.3.</span> <span class="toc-text">现有的线程安全类中添加功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端加锁机制"><span class="toc-number">4.3.1.</span> <span class="toc-text">客户端加锁机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将同步策略文档化"><span class="toc-number">4.4.</span> <span class="toc-text">将同步策略文档化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础构建模块"><span class="toc-number">5.</span> <span class="toc-text">基础构建模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#同步容器类"><span class="toc-number">5.1.</span> <span class="toc-text">同步容器类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步容器类的问题"><span class="toc-number">5.2.</span> <span class="toc-text">同步容器类的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器与ConcurrentModificationExpection"><span class="toc-number">5.2.1.</span> <span class="toc-text">迭代器与ConcurrentModificationExpection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐藏迭代器"><span class="toc-number">5.2.2.</span> <span class="toc-text">隐藏迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发容器"><span class="toc-number">5.3.</span> <span class="toc-text">并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">5.3.1.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#额外的原子map操作"><span class="toc-number">5.3.2.</span> <span class="toc-text">额外的原子map操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">5.3.3.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞队列和生产者消费者模式"><span class="toc-number">5.4.</span> <span class="toc-text">阻塞队列和生产者消费者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#串行线程封闭"><span class="toc-number">5.4.1.</span> <span class="toc-text">串行线程封闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双端队列与工作密取"><span class="toc-number">5.5.</span> <span class="toc-text">双端队列与工作密取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞方法与中断方法"><span class="toc-number">5.6.</span> <span class="toc-text">阻塞方法与中断方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步工具类"><span class="toc-number">5.7.</span> <span class="toc-text">同步工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#闭锁"><span class="toc-number">5.7.1.</span> <span class="toc-text">闭锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask"><span class="toc-number">5.7.2.</span> <span class="toc-text">FutureTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量"><span class="toc-number">5.7.3.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栅栏"><span class="toc-number">5.7.4.</span> <span class="toc-text">栅栏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建高效且可伸缩的结果缓存"><span class="toc-number">5.8.</span> <span class="toc-text">构建高效且可伸缩的结果缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第一部分小结"><span class="toc-number">5.9.</span> <span class="toc-text">第一部分小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二部分-机构化并发应用程序"><span class="toc-number">6.</span> <span class="toc-text">第二部分 机构化并发应用程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#任务执行"><span class="toc-number">7.</span> <span class="toc-text">任务执行</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="SamanthaChen" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/Database/" title="Database">Database<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/DesignPattern/" title="DesignPattern">DesignPattern<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Interview/" title="Interview">Interview<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/JVM/" title="JVM">JVM<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>18</sup></a></li>
		  
		
		  
			<li><a href="/categories/MachineLearning/" title="MachineLearning">MachineLearning<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/Network/" title="Network">Network<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/OS/" title="OS">OS<sup>7</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Interview/" title="Interview">Interview<sup>41</sup></a></li>
			
		
			
				<li><a href="/tags/MachineLearning/" title="MachineLearning">MachineLearning<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Notes/" title="Notes">Notes<sup>23</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>18</sup></a></li>
			
		
			
				<li><a href="/tags/统计学习/" title="统计学习">统计学习<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Algorithm/" title="Algorithm">Algorithm<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/OS/" title="OS">OS<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Network/" title="Network">Network<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/LeetCode/" title="LeetCode">LeetCode<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Database/" title="Database">Database<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/DesignPattern/" title="DesignPattern">DesignPattern<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Concurrentcy/" title="Concurrentcy">Concurrentcy<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Test/" title="Test">Test<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NLP/" title="NLP">NLP<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1544950963&verifier=4d3c970d&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello World, 我叫陈希蔓. <br/>
			这是我的个人技术博客.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1544950963" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/SamanthaChen" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/chen-xi-man" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:chenximan@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="陈希蔓">陈希蔓</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"samanthachen"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4389501af9c71ed21cde31c63d94ebfd";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1259995191'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1259995191' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End --><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  </body>
</html>

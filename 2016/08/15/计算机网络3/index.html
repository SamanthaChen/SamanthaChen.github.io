
 <!DOCTYPE HTML>
<html >
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  
    <title>计算机网络-运输层-笔记 | SamanthaChen&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="陈希蔓">
    

    
    <meta name="description" content="从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。运输层为相互通信的应用进程提供了逻辑通信 。运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务
运输层协议和网络层协议的主要区别
运输层的主要功能运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络-运输层-笔记">
<meta property="og:url" content="http://yoursite.com/2016/08/15/计算机网络3/index.html">
<meta property="og:site_name" content="SamanthaChen's Blog">
<meta property="og:description" content="从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。运输层为相互通信的应用进程提供了逻辑通信 。运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务
运输层协议和网络层协议的主要区别
运输层的主要功能运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network15.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network25.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network16.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network17.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network18.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network33.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network19.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network20.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network21.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network22.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network23.png">
<meta property="og:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network24.png">
<meta property="og:updated_time" content="2016-08-16T08:33:41.596Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机网络-运输层-笔记">
<meta name="twitter:description" content="从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。运输层为相互通信的应用进程提供了逻辑通信 。运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务
运输层协议和网络层协议的主要区别
运输层的主要功能运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻">
<meta name="twitter:image" content="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network15.png">

    
    <link rel="alternative" href="/atom.xml" title="SamanthaChen&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="SamanthaChen&#39;s Blog" title="SamanthaChen&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="SamanthaChen&#39;s Blog">SamanthaChen&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
						<form class="search" action="https://samanthachen.github.io/" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 2073345143534261000 ><input type="text" name="q" size="30" placeholder="Search"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/15/计算机网络3/" title="计算机网络-运输层-笔记" itemprop="url">计算机网络-运输层-笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="陈希蔓" target="_blank" itemprop="author">陈希蔓</a>
		
  <p class="article-time">
    <time datetime="2016-08-15T07:02:17.483Z" itemprop="datePublished"> Published 2016-08-15</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#运输层协议和网络层协议的主要区别"><span class="toc-number">1.</span> <span class="toc-text">运输层协议和网络层协议的主要区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运输层的主要功能"><span class="toc-number">2.</span> <span class="toc-text">运输层的主要功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP与UDP"><span class="toc-number">3.</span> <span class="toc-text">TCP与UDP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运输层的端口（port）"><span class="toc-number">4.</span> <span class="toc-text">运输层的端口（port）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP的端口"><span class="toc-number">4.1.</span> <span class="toc-text">TCP的端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运输层常用的端口号"><span class="toc-number">4.1.1.</span> <span class="toc-text">运输层常用的端口号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用户数据报协议UDP"><span class="toc-number">5.</span> <span class="toc-text">用户数据报协议UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#主要特点"><span class="toc-number">5.1.</span> <span class="toc-text">主要特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向报文的UDP"><span class="toc-number">5.2.</span> <span class="toc-text">面向报文的UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP报文格式"><span class="toc-number">5.3.</span> <span class="toc-text">UDP报文格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#传输控制协议TCP"><span class="toc-number">6.</span> <span class="toc-text">传输控制协议TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP主要特点"><span class="toc-number">6.1.</span> <span class="toc-text">TCP主要特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP面向字节流"><span class="toc-number">6.2.</span> <span class="toc-text">TCP面向字节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP的连接"><span class="toc-number">6.3.</span> <span class="toc-text">TCP的连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可靠传输"><span class="toc-number">6.4.</span> <span class="toc-text">可靠传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-可靠通信的具体实现"><span class="toc-number">6.5.</span> <span class="toc-text">TCP 可靠通信的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP报文的首部格式"><span class="toc-number">6.6.</span> <span class="toc-text">TCP报文的首部格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP的流量控制"><span class="toc-number">6.7.</span> <span class="toc-text">TCP的流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何改进传输层的性能？"><span class="toc-number">6.7.1.</span> <span class="toc-text">如何改进传输层的性能？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP拥塞控制"><span class="toc-number">6.8.</span> <span class="toc-text">TCP拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#慢开始和拥塞避免"><span class="toc-number">6.8.1.</span> <span class="toc-text">慢开始和拥塞避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快重传和快恢复"><span class="toc-number">6.8.2.</span> <span class="toc-text">快重传和快恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拥塞控制与流量控制的关系"><span class="toc-number">6.9.</span> <span class="toc-text">拥塞控制与流量控制的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的窗口管理机制"><span class="toc-number">6.9.1.</span> <span class="toc-text">TCP的窗口管理机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP运输管理"><span class="toc-number">6.10.</span> <span class="toc-text">TCP运输管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三次握手连接建立"><span class="toc-number">6.10.1.</span> <span class="toc-text">三次握手连接建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四次挥手连接释放"><span class="toc-number">6.10.2.</span> <span class="toc-text">四次挥手连接释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP有限状态机"><span class="toc-number">6.11.</span> <span class="toc-text">TCP有限状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一些问题"><span class="toc-number">6.11.1.</span> <span class="toc-text">一些问题</span></a></li></ol></li></ol></li></ol>
		
		</div>
		
		<p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。<br>运输层为相互通信的应用进程提供了逻辑通信 。<br>运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务</p>
<h1 id="运输层协议和网络层协议的主要区别"><a href="#运输层协议和网络层协议的主要区别" class="headerlink" title="运输层协议和网络层协议的主要区别"></a>运输层协议和网络层协议的主要区别</h1><p><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network15.png" alt=""></p>
<h1 id="运输层的主要功能"><a href="#运输层的主要功能" class="headerlink" title="运输层的主要功能"></a>运输层的主要功能</h1><p>运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）。<br>运输层还要对收到的报文进行差错检测。<br>运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。   </p>
<p>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。<br>当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 </p>
<h1 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h1><p>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU (Transport Protocol Data Unit)。<br>TCP 传送的数据单位协议是 TCP 报文段(segment)<br>UDP 传送的数据单位协议是 UDP 报文或用户数据报。 </p>
<p>运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。IP 数据报要经过互连网中许多路由器的存储转发，但 UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。<br>TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。 </p>
<h1 id="运输层的端口（port）"><a href="#运输层的端口（port）" class="headerlink" title="运输层的端口（port）"></a>运输层的端口（port）</h1><p>运行在计算机中的进程是用进程标识符来标志的，而不同的操作系统又使用不同格式的进程标识符。<br>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。 </p>
<p>解决这个问题的方法就是在运输层使用协议端口号(protocol port number)，或通常简称为端口(port)。<br>虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。</p>
<p>注意区分硬件端口和软件端口：前者是接口，后者是地址。</p>
<h2 id="TCP的端口"><a href="#TCP的端口" class="headerlink" title="TCP的端口"></a>TCP的端口</h2><p>端口用一个 16 位端口号进行标志。<br>端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。</p>
<p>三种端口：<br>熟知端口，数值一般为 0~1023。<br>登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。<br>客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 </p>
<h3 id="运输层常用的端口号"><a href="#运输层常用的端口号" class="headerlink" title="运输层常用的端口号"></a>运输层常用的端口号</h3><p><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network25.png" alt=""></p>
<h1 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h1><p>UDP 只在IP的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。<br>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。</p>
<h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ul>
<li>UDP 是无连接的，即发送数据之前不需要建立连接。</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</li>
<li>UDP 是面向报文的（几乎不改变报文）。UDP 没有拥塞控制，很适合多媒体通信的要求。 </li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>UDP 的首部开销小，只有 8 个字节。 </li>
</ul>
<h2 id="面向报文的UDP"><a href="#面向报文的UDP" class="headerlink" title="面向报文的UDP"></a>面向报文的UDP</h2><p>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。<br>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。<br>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。<br>应用程序必须选择合适大小的报文。</p>
<h2 id="UDP报文格式"><a href="#UDP报文格式" class="headerlink" title="UDP报文格式"></a>UDP报文格式</h2><p><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network16.png" alt=""><br>用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段有 8 个字节，由 4 个字段组成，每个字段都是两个字节。<br>在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。</p>
<h1 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h1><h2 id="TCP主要特点"><a href="#TCP主要特点" class="headerlink" title="TCP主要特点"></a>TCP主要特点</h2><p>TCP 是面向连接的运输层协议。<br>每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。<br>TCP 提供可靠交付的服务。<br> TCP 提供全双工通信。<br>面向字节流。  </p>
<h2 id="TCP面向字节流"><a href="#TCP面向字节流" class="headerlink" title="TCP面向字节流"></a>TCP面向字节流</h2><ul>
<li>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。</li>
<li>CP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</li>
<li>TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 </li>
</ul>
<h2 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h2><p>TCP 连接的端点叫做套接字(socket)或插口。<br>端口号拼接到(contatenated with) IP 地址即构成了套接字。   </p>
<p>套接字 socket = (IP地址: 端口号)    </p>
<p>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定：<br>  TCP 连接 ::= {socket1, socket2}<br>             = {(IP1: port1), (IP2: port2)}     </p>
<p>同一个名词 socket有多种不同的意思 </p>
<h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><ol>
<li>停止等待协议 </li>
<li>连续 ARQ 协议 </li>
</ol>
<h2 id="TCP-可靠通信的具体实现"><a href="#TCP-可靠通信的具体实现" class="headerlink" title="TCP 可靠通信的具体实现"></a>TCP 可靠通信的具体实现</h2><ul>
<li>TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。</li>
<li>TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。</li>
<li>TCP 两端的四个窗口经常处于动态变化之中。</li>
<li>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。  </li>
</ul>
<h2 id="TCP报文的首部格式"><a href="#TCP报文的首部格式" class="headerlink" title="TCP报文的首部格式"></a>TCP报文的首部格式</h2><p><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network17.png" alt=""></p>
<ul>
<li>源端口和目的端口：各16位；</li>
<li>序号和确认号：以字节为单位编号，各32位；<br> TCP 每次发送的报文段的首部中的序号字段数值表示该报文段第一个字节的序号。<br> TCP 确认号表示接收端期望下次收到的数据中的第一个数据字节的序号。  </li>
<li>TCP头的长度：4位，长度单位为32位字；</li>
<li>6位的保留域；</li>
<li>6位的标识位：置1表示有效<br> URG：和紧急指针配合使用，发送紧急数据；<br> ACK：确认号是否有效；<br> PSH：指示发送方和接收方将数据不做缓存，立刻发送或接收；<br> RST：由于不可恢复的错误重置连接；<br> SYN：用于连接建立指示；<br> FIN：用于连接释放指示</li>
<li>窗口大小：用于基于可变滑动窗口的流控，指示发送方从确认号开始可以再发送窗口大小的字节流；</li>
<li>校验和：为增加可靠性，对TCP头，数据和伪头计算校验和；</li>
<li>选项字段 —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”</li>
</ul>
<h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p>流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞（对资源需求的总和 &gt; 可用资源）。<br>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。<br><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network18.png" alt=""><br><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network33.png" alt=""><br>如图所示，说明了利用可变窗口大小进行流量控制。设主机A向主机B发送数据。双方确定的窗口值是400.再设每一个报文段为100字节长，序号的初始值为seq=1,图中的箭头上面大写ACK，表示首部中的确认为为ACK，小写ack表示确认字段的值。</p>
<p>接收方的主机B进行了三次流量控制。第一次把窗口设置为rwind=300，第二次减小到rwind=100最后减到rwind=0，即不允许发送方再发送过数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。</p>
<p>假如，B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwind=400的报文段，然而这个报文段在传送中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。这样就死锁了。为了解决这种死锁状态，TCP为每个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</p>
<h3 id="如何改进传输层的性能？"><a href="#如何改进传输层的性能？" class="headerlink" title="如何改进传输层的性能？"></a>如何改进传输层的性能？</h3><p>策略1：发送方缓存应用程序的数据，等到形成一个比较大的段再发出；<br>策略2：在没有可能进行“捎带”的情况下，接收方延迟发送确认段；<br>策略3：使用Nagle算法<br>    当应用程序每次向传输实体发出一个字节时，传输实体发出第一个字节并缓存所有其后的字节直至收到对第一个字节的确认<br>    适用于数据发送速度快，而网速较慢的情况<br>策略4：使用Clark算法解决傻窗口症状（silly window syndrome）<br>    傻窗口症状：当应用程序一次从传输层实体读出一个字节时，传输层实体会产生一个一字节的窗口更新段，使得发送方只能发送一个字节；<br>    解决办法：限制收方只有在具备一半的空缓存或最大段长的空缓存时，才产生一个窗口更新段。</p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞(congestion)。<br>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。 </p>
<p>出现拥塞的两种情况：</p>
<pre><code>- 快网络小缓存接收者
- 慢网络大缓存接收者
导致网络拥塞的两个潜在因素
     - 网络能力
     - 接收能力
</code></pre><p>TCP处理第一种拥塞的措施<br>（快网络小缓存）</p>
<pre><code>- 在连接建立时声明最大可接受段长度；
- 利用可变滑动窗口协议防止出现拥塞；
</code></pre><p>TCP处理第二种拥塞的措施<br>（慢网络大缓存）：</p>
<pre><code>- 发送方维护两个窗口：接收方和拥塞窗口，发送方窗口按两个窗口的最小值发送；
- 拥塞窗口依照慢启动（slow start）算法和拥塞避免（congestion avoidance）算法变化。
</code></pre><p>几种拥塞控制的方法：</p>
<pre><code>1. 慢开始和拥塞避免
2. 快重传和快恢复
</code></pre><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><ul>
<li>发送方维持一个叫做拥塞窗口 cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。</li>
<li>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 </li>
</ul>
<p>1、慢启动（slow start）算法<br>连接建立时拥塞窗口（cwnd）初始值为该连接允许的最大段长，阈值（threshold）为64K；<br>发出一个最大段长的TCP段，若正确确认，拥塞窗口变为两个最大段长；<br>发出（ 拥塞窗口/最大段长）个最大长度的TCP段，若都得到确认，则拥塞窗口加倍；<br>重复上一步，直至发生丢包超时事件，或拥塞窗口大于阈值。</p>
<p>2、拥塞避免（congestion avoidance）算法<br>若拥塞窗口大于阈值，从此时开始，拥塞窗口线形增长，一个RTT周期增加一个最大段长，直至发生丢包超时事件；<br>当超时事件发生后，阈值设置为当前拥塞窗口大小的一半，拥塞窗口重新设置为一个最大段长；<br>执行慢启动算法。</p>
<p><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network19.png" alt=""></p>
<ol>
<li>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为 1，发送第一个报文段 M0。  </li>
<li>发送端每收到一个确认 ，就把 cwnd 加 1。于是发送端可以接着发送 M1 和 M2 两个报文段。 </li>
<li>接收端共发回两个确认。发送端每收到一个对新报文段的确认，就把发送端的 cwnd 加 1。现在 cwnd 从 2 增大到 4，并可接着发送后面的 4 个报文段。</li>
<li>发送端每收到一个对新报文段的确认，就把发送端的拥塞窗口加 1，因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。 </li>
<li>当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当 cwnd = 16 时），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。 </li>
<li>假定拥塞窗口的数值增长到 24 时，网络出现超时，表明网络拥塞了。 </li>
<li>更新后的 ssthresh 值变为 12（即发送窗口数值 24 的一半），拥塞窗口再重新设置为 1，并执行慢开始算法。 </li>
<li>当 cwnd = 12 时改为执行拥塞避免算法，拥塞窗口按按线性规律增长，每经过一个往返时延就增加一个 MSS 的大小。 </li>
</ol>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>快重传：</p>
<ul>
<li>引入：为了解决等待重传计时器超时引起的信道空闲</li>
<li>快重传算法规定，发送端只要一连收到三个重复的 ACK 即可断定有分组丢失了，就应立即重传丢失的报文段而不必继续等待重传超时。<br><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network20.png" alt=""></li>
</ul>
<p>快恢复：<br>(1) 当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。<br>(2)由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。<br><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network21.png" alt=""></p>
<h2 id="拥塞控制与流量控制的关系"><a href="#拥塞控制与流量控制的关系" class="headerlink" title="拥塞控制与流量控制的关系"></a>拥塞控制与流量控制的关系</h2><ul>
<li>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 </li>
<li>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。 </li>
<li>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 </li>
</ul>
<p>接收端窗口 rwnd (receiver window)，拥塞窗口 cwnd (congestion window) </p>
<h3 id="TCP的窗口管理机制"><a href="#TCP的窗口管理机制" class="headerlink" title="TCP的窗口管理机制"></a>TCP的窗口管理机制</h3><p>基于确认和可变窗口大小；<br>窗口大小为0时，正常情况下，发送方不能再发TCP段<br>但有两个例外：<br>    紧急数据可以发送；<br>    为防止死锁，发送方可以发送1字节的TCP段，以便让接收方重新声明确认号和窗口大小。</p>
<h2 id="TCP运输管理"><a href="#TCP运输管理" class="headerlink" title="TCP运输管理"></a>TCP运输管理</h2><p>运输连接就有三个阶段，即：连接建立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。<br>TCP 连接的建立都是采用客户服务器方式。<br>主动发起连接建立的应用进程叫做客户(client)。<br>被动等待连接建立的应用进程叫做服务器(server)。 </p>
<h3 id="三次握手连接建立"><a href="#三次握手连接建立" class="headerlink" title="三次握手连接建立"></a>三次握手连接建立</h3><p><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network22.png" alt=""></p>
<ol>
<li>A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</li>
<li>B 的 TCP 收到连接请求报文段后，如同意，则发回确认。B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。</li>
<li>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。A 的 TCP 通知上层应用进程，连接已经建立。</li>
<li>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。</li>
</ol>
<h3 id="四次挥手连接释放"><a href="#四次挥手连接释放" class="headerlink" title="四次挥手连接释放"></a>四次挥手连接释放</h3><p><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network23.png" alt=""></p>
<ol>
<li>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。</li>
<li>B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。TCP服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于<strong>半关闭</strong>状态。B 若发送数据，A 仍要接收</li>
<li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。</li>
<li>A 收到连接释放报文段后，必须发出确认。</li>
</ol>
<p>A必须等待2MSL：<br>第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。<br>第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<h2 id="TCP有限状态机"><a href="#TCP有限状态机" class="headerlink" title="TCP有限状态机"></a>TCP有限状态机</h2><ul>
<li>TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态。</li>
<li>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。</li>
<li>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</li>
<li>图中有三种不同的箭头。<br> 粗实线箭头表示对客户进程的正常变迁。<br> 粗虚线箭头表示对服务器进程的正常变迁。<br> 另一种细线箭头表示异常变迁<br><img src="https://raw.githubusercontent.com/SamanthaChen/GitPicbed/master/Network/network24.png" alt=""><br>CLOSED：表示初始状态。对服务端和C客户端双方都一样。<br>LISTEN：表示监听状态。服务端调用了listen函数，可以开始accept连接了。<br>SYN_SENT：表示客户端已经发送了SYN报文。当客户端调用connect函数发起连接时，首先发SYN给服务端，然后自己进入SYN_SENT状态，<pre><code>并等待服务端发送ACK+SYN。
</code></pre>SYN_RCVD：表示服务端收到客户端发送SYN报文。服务端收到这个报文后，进入SYN_RCVD状态，然后发送ACK+SYN给客户端。<br>ESTABLISHED：表示连接已经建立成功了。服务端发送完ACK+SYN后进入该状态，客户端收到ACK后也进入该状态。<br>FIN_WAIT_1：表示主动关闭连接。无论哪方调用close函数发送FIN报文都会进入这个这个状态。<br>FIN_WAIT_2：表示被动关闭方同意关闭连接。主动关闭连接方收到被动关闭方返回的ACK后，会进入该状态。<br>TIME_WAIT：表示收到对方的FIN报文并发送了ACK报文，就等2MSL后即可回到CLOSED状态了。如果FIN_WAIT_1状态下，收到对方同时带FIN标志和ACK标志的报文时，可以直接进入TIME_WAIT状态，而无须经过FIN_WAIT_2状态。<br>CLOSING：表示双方同时关闭连接。如果双方几乎同时调用close函数，那么会出现双方同时发送FIN报文的情况，就会出现CLOSING状态，表示双方都在关闭连接。<br>CLOSE_WAIT：表示被动关闭方等待关闭。当收到对方调用close函数发送的FIN报文时，回应对方ACK报文，此时进入CLOSE_WAIT状态。<br>LAST_ACK：表示被动关闭方发送FIN报文后，等待对方的ACK报文状态，当收到ACK后进入CLOSED状态。</li>
</ul>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul>
<li><p>Q1 为什么在TCP协议里，建立连接是三次握手，而关闭连接却是四次握手呢？</p>
<ul>
<li>因为当处于LISTEN 状态的服务器端SOCKET当收到SYN报文（客户端希望新建一个TCP连接）后，它可以把ACK（应答作用）和SYN（同步作用）放在同一个报文里来发送给客户端。但在关闭TCP连接时，当收到对方的FIN报文时，对方仅仅表示对方没有数据发送给你了，但未必你的所有数据都已经全部发送给了对方，所以你大可不必马上关闭SOCKET（发送一个FIN报文），等你发送完剩余的数据给对方之后，再发送FIN报文给对方来表示你同意现在关闭连接了，所以通常情况下，这里的ACK报文和FIN报文都是分开发送的。</li>
</ul>
</li>
<li><p>Q2 为什么TIME_WAIT 状态还需要等2*MSL秒之后才能返回到CLOSED 状态呢？</p>
<ul>
<li>因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED 状态（就好比从SYN_SENT 状态到ESTABLISH 状态那样），但是我们必须假想网络是不可靠的，你无法保证你(客户端)最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK 状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT 状态的作用就是用来重发可能丢失的ACK报文。</li>
</ul>
</li>
</ul>
<ul>
<li>Q3 关闭TCP连接一定需要4次挥手吗？<ul>
<li>不一定，4次挥手关闭TCP连接是最安全的做法。但在有些时候，我们不喜欢TIME_WAIT 状态（如当MSL数值设置过大导致服务器端有太多TIME_WAIT状态的TCP连接，减少这些条目数可以更快地关闭连接，为新连接释放更多资源），这时我们可以通过设置SOCKET变量的SO_LINGER标志来避免SOCKET在close()之后进入TIME_WAIT状态，这时将通过发送RST强制终止TCP连接（取代正常的TCP四次握手的终止方式）。但这并不是一个很好的主意，TIME_WAIT 对于我们来说往往是有利的。</li>
</ul>
</li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Network/">Network</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Network/">Network</a><a href="/tags/Interview/">Interview</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/08/15/计算机网络3/" data-title="计算机网络-运输层-笔记 | SamanthaChen&#39;s Blog" data-tsina="1544950963" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/08/15/计算机网络4/" title="计算机网络-应用层-笔记">
  <strong>上一篇：</strong><br/>
  <span>
  计算机网络-应用层-笔记</span>
</a>
</div>


<div class="next">
<a href="/2016/08/15/计算机网络2/"  title="计算机网络-网络层-笔记">
 <strong>下一篇：</strong><br/> 
 <span>计算机网络-网络层-笔记
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/08/15/计算机网络3/" data-title="计算机网络-运输层-笔记" data-url="http://yoursite.com/2016/08/15/计算机网络3/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#运输层协议和网络层协议的主要区别"><span class="toc-number">1.</span> <span class="toc-text">运输层协议和网络层协议的主要区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运输层的主要功能"><span class="toc-number">2.</span> <span class="toc-text">运输层的主要功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP与UDP"><span class="toc-number">3.</span> <span class="toc-text">TCP与UDP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运输层的端口（port）"><span class="toc-number">4.</span> <span class="toc-text">运输层的端口（port）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP的端口"><span class="toc-number">4.1.</span> <span class="toc-text">TCP的端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运输层常用的端口号"><span class="toc-number">4.1.1.</span> <span class="toc-text">运输层常用的端口号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用户数据报协议UDP"><span class="toc-number">5.</span> <span class="toc-text">用户数据报协议UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#主要特点"><span class="toc-number">5.1.</span> <span class="toc-text">主要特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向报文的UDP"><span class="toc-number">5.2.</span> <span class="toc-text">面向报文的UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP报文格式"><span class="toc-number">5.3.</span> <span class="toc-text">UDP报文格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#传输控制协议TCP"><span class="toc-number">6.</span> <span class="toc-text">传输控制协议TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP主要特点"><span class="toc-number">6.1.</span> <span class="toc-text">TCP主要特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP面向字节流"><span class="toc-number">6.2.</span> <span class="toc-text">TCP面向字节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP的连接"><span class="toc-number">6.3.</span> <span class="toc-text">TCP的连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可靠传输"><span class="toc-number">6.4.</span> <span class="toc-text">可靠传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-可靠通信的具体实现"><span class="toc-number">6.5.</span> <span class="toc-text">TCP 可靠通信的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP报文的首部格式"><span class="toc-number">6.6.</span> <span class="toc-text">TCP报文的首部格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP的流量控制"><span class="toc-number">6.7.</span> <span class="toc-text">TCP的流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何改进传输层的性能？"><span class="toc-number">6.7.1.</span> <span class="toc-text">如何改进传输层的性能？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP拥塞控制"><span class="toc-number">6.8.</span> <span class="toc-text">TCP拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#慢开始和拥塞避免"><span class="toc-number">6.8.1.</span> <span class="toc-text">慢开始和拥塞避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快重传和快恢复"><span class="toc-number">6.8.2.</span> <span class="toc-text">快重传和快恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拥塞控制与流量控制的关系"><span class="toc-number">6.9.</span> <span class="toc-text">拥塞控制与流量控制的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的窗口管理机制"><span class="toc-number">6.9.1.</span> <span class="toc-text">TCP的窗口管理机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP运输管理"><span class="toc-number">6.10.</span> <span class="toc-text">TCP运输管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三次握手连接建立"><span class="toc-number">6.10.1.</span> <span class="toc-text">三次握手连接建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四次挥手连接释放"><span class="toc-number">6.10.2.</span> <span class="toc-text">四次挥手连接释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP有限状态机"><span class="toc-number">6.11.</span> <span class="toc-text">TCP有限状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一些问题"><span class="toc-number">6.11.1.</span> <span class="toc-text">一些问题</span></a></li></ol></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github Card</p>
<div class="github-card" data-github="SamanthaChen" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/Database/" title="Database">Database<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/DesignPattern/" title="DesignPattern">DesignPattern<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Interview/" title="Interview">Interview<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/JVM/" title="JVM">JVM<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>18</sup></a></li>
		  
		
		  
			<li><a href="/categories/MachineLearning/" title="MachineLearning">MachineLearning<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/Network/" title="Network">Network<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/OS/" title="OS">OS<sup>7</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Interview/" title="Interview">Interview<sup>42</sup></a></li>
			
		
			
				<li><a href="/tags/MachineLearning/" title="MachineLearning">MachineLearning<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Notes/" title="Notes">Notes<sup>23</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>18</sup></a></li>
			
		
			
				<li><a href="/tags/统计学习/" title="统计学习">统计学习<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Algorithm/" title="Algorithm">Algorithm<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/OS/" title="OS">OS<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Network/" title="Network">Network<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/LeetCode/" title="LeetCode">LeetCode<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Database/" title="Database">Database<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Concurrentcy/" title="Concurrentcy">Concurrentcy<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/DesignPattern/" title="DesignPattern">DesignPattern<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/NLP/" title="NLP">NLP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Test/" title="Test">Test<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1544950963&verifier=4d3c970d&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello World, 我叫陈希蔓. <br/>
			这是我的个人技术博客.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1544950963" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/SamanthaChen" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/chen-xi-man" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:chenximan@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="陈希蔓">陈希蔓</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"samanthachen"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4389501af9c71ed21cde31c63d94ebfd";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1259995191'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1259995191' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End --><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  </body>
</html>

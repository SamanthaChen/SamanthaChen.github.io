
 <!DOCTYPE HTML>
<html >
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  
    <title>Java并发 | SamanthaChen&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="陈希蔓">
    

    
    <meta name="description" content="并发编程网
多线程的优点和代价优点：

资源利用率更好
程序设计在某些情况下更简单
程序响应更快代价：
设计更复杂
上下文切换的开销
增加资源消耗

并发编程的模型并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。目前（2015年）比较流行的几种并发模型。
并发模型与分布式">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发">
<meta property="og:url" content="http://yoursite.com/2016/08/22/java并发/index.html">
<meta property="og:site_name" content="SamanthaChen's Blog">
<meta property="og:description" content="并发编程网
多线程的优点和代价优点：

资源利用率更好
程序设计在某些情况下更简单
程序响应更快代价：
设计更复杂
上下文切换的开销
增加资源消耗

并发编程的模型并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。目前（2015年）比较流行的几种并发模型。
并发模型与分布式">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-7.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-8.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency-utils/blocking-queue.png">
<meta property="og:image" content="https://camo.githubusercontent.com/720fd34b938c645d6d42b41e5d694fb9d2d71a61/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d312e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/3f3647ee8e4af4140e5414eb296d8f2d4e83a3fb/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d322e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/74cd8d994d0be5bee55c55c72b3ce86a673cf86f/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d332e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/97a2b4ea28a6d8fb79460d847acf047603c3b975/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d342e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/c4d52cd702c9ad3124a62a76ee9493da43d07562/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d352e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/e8ddaa9c30791bc7ed8f09c92585cb11b724558c/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d362e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/f9261b92dd8f8f5e9b8f26c9234f0aec66cfb012/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f616d6461686c732d6c61772d312e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/0117abdf5ee0ce2c427d65957c4e3a0479738f98/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f616d6461686c732d6c61772d322e706e67">
<meta property="og:updated_time" content="2016-08-25T06:31:54.823Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发">
<meta name="twitter:description" content="并发编程网
多线程的优点和代价优点：

资源利用率更好
程序设计在某些情况下更简单
程序响应更快代价：
设计更复杂
上下文切换的开销
增加资源消耗

并发编程的模型并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。目前（2015年）比较流行的几种并发模型。
并发模型与分布式">
<meta name="twitter:image" content="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png">

    
    <link rel="alternative" href="/atom.xml" title="SamanthaChen&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="SamanthaChen&#39;s Blog" title="SamanthaChen&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="SamanthaChen&#39;s Blog">SamanthaChen&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
						<form class="search" action="https://samanthachen.github.io/" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 2073345143534261000 ><input type="text" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/22/java并发/" title="Java并发" itemprop="url">Java并发</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="陈希蔓" target="_blank" itemprop="author">陈希蔓</a>
		
  <p class="article-time">
    <time datetime="2016-08-22T08:31:51.664Z" itemprop="datePublished"> 发表于 2016-08-22</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#多线程的优点和代价"><span class="toc-number">1.</span> <span class="toc-text">多线程的优点和代价</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发编程的模型"><span class="toc-number">2.</span> <span class="toc-text">并发编程的模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发模型与分布式系统之间的相似性"><span class="toc-number">2.1.</span> <span class="toc-text">并发模型与分布式系统之间的相似性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行工作者"><span class="toc-number">2.2.</span> <span class="toc-text">并行工作者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并行工作者模型的优点"><span class="toc-number">2.2.1.</span> <span class="toc-text">并行工作者模型的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行工作者模型的缺点"><span class="toc-number">2.2.2.</span> <span class="toc-text">并行工作者模型的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#共享状态可能会很复杂"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">共享状态可能会很复杂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无状态的工作者"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">无状态的工作者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#任务顺序是不确定的"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">任务顺序是不确定的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流水线模式"><span class="toc-number">2.3.</span> <span class="toc-text">流水线模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#反应器，事件驱动系统"><span class="toc-number">2.3.1.</span> <span class="toc-text">反应器，事件驱动系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Actors-和-Channels"><span class="toc-number">2.3.2.</span> <span class="toc-text">Actors 和 Channels</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流水线模型的优点"><span class="toc-number">2.3.3.</span> <span class="toc-text">流水线模型的优点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#无需共享的状态"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">无需共享的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有状态的工作者"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">有状态的工作者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hardware-Conformity"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">Hardware Conformity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#合理的作业顺序"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">合理的作业顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点"><span class="toc-number">2.3.3.5.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式并行（Functional-Parallelism）"><span class="toc-number">2.4.</span> <span class="toc-text">函数式并行（Functional Parallelism）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用那种并发模型最好？"><span class="toc-number">2.5.</span> <span class="toc-text">使用那种并发模型最好？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建并运行java线程"><span class="toc-number">3.</span> <span class="toc-text">创建并运行java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建Thread的子类"><span class="toc-number">3.1.</span> <span class="toc-text">创建Thread的子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现Runnable接口"><span class="toc-number">3.2.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建子类还是实现Runnable接口？"><span class="toc-number">3.3.</span> <span class="toc-text">创建子类还是实现Runnable接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见错误：调用run-方法而非start-方法"><span class="toc-number">3.4.</span> <span class="toc-text">常见错误：调用run()方法而非start()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程代码举例："><span class="toc-number">3.5.</span> <span class="toc-text">线程代码举例：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#竞态条件与临界区"><span class="toc-number">4.</span> <span class="toc-text">竞态条件与临界区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程安全与共享资源"><span class="toc-number">5.</span> <span class="toc-text">线程安全与共享资源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#局部变量"><span class="toc-number">5.1.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#局部的对象引用"><span class="toc-number">5.2.</span> <span class="toc-text">局部的对象引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象成员"><span class="toc-number">5.3.</span> <span class="toc-text">对象成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程控制逃逸规则"><span class="toc-number">5.4.</span> <span class="toc-text">线程控制逃逸规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程安全及不可变性"><span class="toc-number">6.</span> <span class="toc-text">线程安全及不可变性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java内存模型"><span class="toc-number">7.</span> <span class="toc-text">java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java内存模型和硬件内存架构之间的桥接"><span class="toc-number">7.1.</span> <span class="toc-text">Java内存模型和硬件内存架构之间的桥接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享对象可见性"><span class="toc-number">7.2.</span> <span class="toc-text">共享对象可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#竞态"><span class="toc-number">7.3.</span> <span class="toc-text">竞态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java同步块"><span class="toc-number">8.</span> <span class="toc-text">java同步块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-同步关键字（synchronized）"><span class="toc-number">8.1.</span> <span class="toc-text">Java 同步关键字（synchronized）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例方法同步"><span class="toc-number">8.2.</span> <span class="toc-text">实例方法同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态方法同步"><span class="toc-number">8.3.</span> <span class="toc-text">静态方法同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例方法中的同步块"><span class="toc-number">8.4.</span> <span class="toc-text">实例方法中的同步块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态方法中的同步块"><span class="toc-number">8.5.</span> <span class="toc-text">静态方法中的同步块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java同步实例"><span class="toc-number">8.6.</span> <span class="toc-text">Java同步实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程通信"><span class="toc-number">9.</span> <span class="toc-text">线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通过共享对象通信"><span class="toc-number">9.1.</span> <span class="toc-text">通过共享对象通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#忙等待-Busy-Wait"><span class="toc-number">9.2.</span> <span class="toc-text">忙等待(Busy Wait)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-notify-和notifyAll"><span class="toc-number">9.3.</span> <span class="toc-text">wait(),notify()和notifyAll()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#丢失的信号（Missed-Signals）"><span class="toc-number">9.4.</span> <span class="toc-text">丢失的信号（Missed Signals）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#假唤醒"><span class="toc-number">9.5.</span> <span class="toc-text">假唤醒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多个线程等待相同信号"><span class="toc-number">9.6.</span> <span class="toc-text">多个线程等待相同信号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-TheadLocal"><span class="toc-number">10.</span> <span class="toc-text">Java TheadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建一个ThreadLocal对象"><span class="toc-number">10.1.</span> <span class="toc-text">创建一个ThreadLocal对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问ThreadLocal对象"><span class="toc-number">10.2.</span> <span class="toc-text">访问ThreadLocal对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal泛型"><span class="toc-number">10.3.</span> <span class="toc-text">ThreadLocal泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化ThreadLocal"><span class="toc-number">10.4.</span> <span class="toc-text">初始化ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Full-ThreadLocal-Example"><span class="toc-number">10.5.</span> <span class="toc-text">Full ThreadLocal Example</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InheritableThreadLocal"><span class="toc-number">10.6.</span> <span class="toc-text">InheritableThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程通信（待补充）"><span class="toc-number">11.</span> <span class="toc-text">线程通信（待补充）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#死锁"><span class="toc-number">12.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#更复杂的死锁"><span class="toc-number">12.1.</span> <span class="toc-text">更复杂的死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库的死锁"><span class="toc-number">12.2.</span> <span class="toc-text">数据库的死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#避免死锁"><span class="toc-number">13.</span> <span class="toc-text">避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#加锁顺序"><span class="toc-number">13.1.</span> <span class="toc-text">加锁顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁时限"><span class="toc-number">13.2.</span> <span class="toc-text">锁时限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁检测"><span class="toc-number">13.3.</span> <span class="toc-text">死锁检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#饥饿和公平"><span class="toc-number">14.</span> <span class="toc-text">饥饿和公平</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#下面是本文讨论的主题："><span class="toc-number">14.1.</span> <span class="toc-text">下面是本文讨论的主题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中导致饥饿的原因"><span class="toc-number">14.2.</span> <span class="toc-text">Java中导致饥饿的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#高优先级线程吞噬所有的低优先级线程的CPU时间"><span class="toc-number">14.2.1.</span> <span class="toc-text">高优先级线程吞噬所有的低优先级线程的CPU时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程被永久堵塞在一个等待进入同步块的状态"><span class="toc-number">14.2.2.</span> <span class="toc-text">线程被永久堵塞在一个等待进入同步块的状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在Java中实现公平性"><span class="toc-number">14.3.</span> <span class="toc-text">在Java中实现公平性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用锁方式替代同步块"><span class="toc-number">14.3.1.</span> <span class="toc-text">使用锁方式替代同步块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公平锁"><span class="toc-number">14.3.2.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能考虑"><span class="toc-number">14.3.3.</span> <span class="toc-text">性能考虑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套管程锁死"><span class="toc-number">15.</span> <span class="toc-text">嵌套管程锁死</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个更现实的例子"><span class="toc-number">15.1.</span> <span class="toc-text">一个更现实的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#嵌套管程锁死-VS-死锁"><span class="toc-number">15.2.</span> <span class="toc-text">嵌套管程锁死 VS 死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Slipped-Conditions-未完"><span class="toc-number">16.</span> <span class="toc-text">Slipped Conditions(未完)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java中的锁"><span class="toc-number">17.</span> <span class="toc-text">java中的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个简单的锁"><span class="toc-number">17.1.</span> <span class="toc-text">一个简单的锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁的可重入性"><span class="toc-number">17.2.</span> <span class="toc-text">锁的可重入性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁的公平性"><span class="toc-number">17.3.</span> <span class="toc-text">锁的公平性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在finally语句中调用unlock"><span class="toc-number">17.4.</span> <span class="toc-text">在finally语句中调用unlock()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java中的读-写锁"><span class="toc-number">18.</span> <span class="toc-text">Java中的读/写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#读-写锁的Java实现"><span class="toc-number">18.1.</span> <span class="toc-text">读/写锁的Java实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读-写锁的重入"><span class="toc-number">18.2.</span> <span class="toc-text">读/写锁的重入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读锁重入"><span class="toc-number">18.3.</span> <span class="toc-text">读锁重入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写锁重入"><span class="toc-number">18.4.</span> <span class="toc-text">写锁重入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读锁升级到写锁"><span class="toc-number">18.5.</span> <span class="toc-text">读锁升级到写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写锁降级到读锁"><span class="toc-number">18.6.</span> <span class="toc-text">写锁降级到读锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可重入的ReadWriteLock的完整实现"><span class="toc-number">18.7.</span> <span class="toc-text">可重入的ReadWriteLock的完整实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在finally中调用unlock"><span class="toc-number">18.8.</span> <span class="toc-text">在finally中调用unlock()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重入锁死"><span class="toc-number">19.</span> <span class="toc-text">重入锁死</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#信号量"><span class="toc-number">20.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单的Semaphore实现"><span class="toc-number">20.1.</span> <span class="toc-text">简单的Semaphore实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Semaphore来产生信号"><span class="toc-number">20.2.</span> <span class="toc-text">使用Semaphore来产生信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可计数的Semaphore"><span class="toc-number">20.3.</span> <span class="toc-text">可计数的Semaphore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有上限的Semaphore"><span class="toc-number">20.4.</span> <span class="toc-text">有上限的Semaphore</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#阻塞队列"><span class="toc-number">21.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-number">21.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池"><span class="toc-number">22.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java并发编程之CAS"><span class="toc-number">23.</span> <span class="toc-text">Java并发编程之CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS的使用场景"><span class="toc-number">23.1.</span> <span class="toc-text">CAS的使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS用作原子操作"><span class="toc-number">23.2.</span> <span class="toc-text">CAS用作原子操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#同步器"><span class="toc-number">24.</span> <span class="toc-text">同步器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#状态"><span class="toc-number">24.1.</span> <span class="toc-text">状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问条件"><span class="toc-number">24.2.</span> <span class="toc-text">访问条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态变化"><span class="toc-number">24.3.</span> <span class="toc-text">状态变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通知策略"><span class="toc-number">24.4.</span> <span class="toc-text">通知策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Test-and-Set方法"><span class="toc-number">24.5.</span> <span class="toc-text">Test-and-Set方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set方法"><span class="toc-number">24.6.</span> <span class="toc-text">Set方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#非阻塞算法"><span class="toc-number">25.</span> <span class="toc-text">非阻塞算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞并发算法"><span class="toc-number">25.1.</span> <span class="toc-text">阻塞并发算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞并发算法-1"><span class="toc-number">25.2.</span> <span class="toc-text">阻塞并发算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非阻塞并发数据结构"><span class="toc-number">25.3.</span> <span class="toc-text">非阻塞并发数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于volatile变量更高级的数据结构"><span class="toc-number">25.3.1.</span> <span class="toc-text">基于volatile变量更高级的数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用CAS的乐观锁"><span class="toc-number">25.4.</span> <span class="toc-text">使用CAS的乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么称它为乐观锁"><span class="toc-number">25.4.1.</span> <span class="toc-text">为什么称它为乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#乐观锁是非阻塞的"><span class="toc-number">25.4.2.</span> <span class="toc-text">乐观锁是非阻塞的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不可替换的数据结构"><span class="toc-number">25.5.</span> <span class="toc-text">不可替换的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共享预期的修改"><span class="toc-number">25.5.1.</span> <span class="toc-text">共享预期的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可完成的预期修改"><span class="toc-number">25.5.2.</span> <span class="toc-text">可完成的预期修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-B-A问题"><span class="toc-number">25.5.3.</span> <span class="toc-text">A-B-A问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-B-A问题的解决方案"><span class="toc-number">25.5.4.</span> <span class="toc-text">A-B-A问题的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个非阻塞算法模板"><span class="toc-number">25.6.</span> <span class="toc-text">一个非阻塞算法模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非阻塞算法是不容易实现的"><span class="toc-number">25.7.</span> <span class="toc-text">非阻塞算法是不容易实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用非阻塞算法的好处"><span class="toc-number">25.8.</span> <span class="toc-text">使用非阻塞算法的好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#阿姆达定律"><span class="toc-number">26.</span> <span class="toc-text">阿姆达定律</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义"><span class="toc-number">26.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算例子"><span class="toc-number">26.2.</span> <span class="toc-text">计算例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图示"><span class="toc-number">26.3.</span> <span class="toc-text">图示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化算法"><span class="toc-number">26.4.</span> <span class="toc-text">优化算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化串行分量"><span class="toc-number">26.4.1.</span> <span class="toc-text">优化串行分量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时间-vs-加速"><span class="toc-number">26.5.</span> <span class="toc-text">运行时间 vs. 加速</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测量，不要仅是计算"><span class="toc-number">26.6.</span> <span class="toc-text">测量，不要仅是计算</span></a></li></ol></li></ol>
		
		</div>
		
		<p><a href="http://ifeve.com/java-concurrency-thread-directory/" target="_blank" rel="external">并发编程网</a></p>
<h1 id="多线程的优点和代价"><a href="#多线程的优点和代价" class="headerlink" title="多线程的优点和代价"></a>多线程的优点和代价</h1><p>优点：</p>
<ul>
<li>资源利用率更好</li>
<li>程序设计在某些情况下更简单</li>
<li>程序响应更快<br>代价：</li>
<li>设计更复杂</li>
<li>上下文切换的开销</li>
<li>增加资源消耗</li>
</ul>
<h1 id="并发编程的模型"><a href="#并发编程的模型" class="headerlink" title="并发编程的模型"></a>并发编程的模型</h1><p>并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。目前（2015年）比较流行的几种并发模型。</p>
<h2 id="并发模型与分布式系统之间的相似性"><a href="#并发模型与分布式系统之间的相似性" class="headerlink" title="并发模型与分布式系统之间的相似性"></a>并发模型与分布式系统之间的相似性</h2><p>本文所描述的并发模型类似于分布式系统中使用的很多体系结构。在并发系统中线程之间可以相互通信。在分布式系统中进程之间也可以相互通信（进程有可能在不同的机器中）。线程和进程之间具有很多相似的特性。这也就是为什么很多并发模型通常类似于各种分布式系统架构。</p>
<p>当然，分布式系统在处理网络失效、远程主机或进程宕掉等方面也面临着额外的挑战。但是运行在巨型服务器上的并发系统也可能遇到类似的问题，比如一块CPU失效、一块网卡失效或一个磁盘损坏等情况。虽然出现失效的概率可能很低，但是在理论上仍然有可能发生。</p>
<p>由于并发模型类似于分布式系统架构，因此它们通常可以互相借鉴思想。例如，为工作者们（线程）分配作业的模型一般与分布式系统中的负载均衡系统比较相似。同样，它们在日志记录、失效转移、幂等性等错误处理技术上也具有相似性。</p>
<h2 id="并行工作者"><a href="#并行工作者" class="headerlink" title="并行工作者"></a>并行工作者</h2><p>第一种并发模型就是我所说的并行工作者模型。传入的作业会被分配到不同的工作者上。下图展示了并行工作者模型：<br><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png" alt=""><br>在并行工作者模型中，委派者（Delegator）将传入的作业分配给不同的工作者。每个工作者完成整个任务。工作者们并行运作在不同的线程上，甚至可能在不同的CPU上。</p>
<p>如果在某个汽车厂里实现了并行工作者模型，每台车都会由一个工人来生产。工人们将拿到汽车的生产规格，并且从头到尾负责所有工作。</p>
<p>在Java应用系统中，并行工作者模型是最常见的并发模型（即使正在转变）。java.util.concurrent包中的许多并发实用工具都是设计用于这个模型的。你也可以在Java企业级（J2EE）应用服务器的设计中看到这个模型的踪迹。</p>
<h3 id="并行工作者模型的优点"><a href="#并行工作者模型的优点" class="headerlink" title="并行工作者模型的优点"></a>并行工作者模型的优点</h3><p>并行工作者模式的优点是，它很容易理解。你只需添加更多的工作者来提高系统的并行度。</p>
<p>例如，如果你正在做一个网络爬虫，可以试试使用不同数量的工作者抓取到一定数量的页面，然后看看多少数量的工作者消耗的时间最短（意味着性能最高）。由于网络爬虫是一个IO密集型工作，最终结果很有可能是你电脑中的每个CPU或核心分配了几个线程。每个CPU若只分配一个线程可能有点少，因为在等待数据下载的过程中CPU将会空闲大量时间。</p>
<h3 id="并行工作者模型的缺点"><a href="#并行工作者模型的缺点" class="headerlink" title="并行工作者模型的缺点"></a>并行工作者模型的缺点</h3><p>并行工作者模型虽然看起来简单，却隐藏着一些缺点。接下来的章节中我会分析一些最明显的弱点。<br>并行工作者模型虽然看起来简单，却隐藏着一些缺点。接下来的章节中我会分析一些最明显的弱点。</p>
<h4 id="共享状态可能会很复杂"><a href="#共享状态可能会很复杂" class="headerlink" title="共享状态可能会很复杂"></a>共享状态可能会很复杂</h4><p>在实际应用中，并行工作者模型可能比前面所描述的情况要复杂得多。共享的工作者经常需要访问一些共享数据，无论是内存中的或者共享的数据库中的。下图展示了并行工作者模型是如何变得复杂的：<br><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png" alt=""><br>有些共享状态是在像作业队列这样的通信机制下。但也有一些共享状态是业务数据，数据缓存，数据库连接池等。</p>
<ul>
<li>一旦共享状态潜入到并行工作者模型中，将会使情况变得复杂起来。线程需要以某种方式存取共享数据，以确保某个线程的修改能够对其他线程可见（数据修改需要同步到主存中，不仅仅将数据保存在执行这个线程的CPU的缓存中）。线程需要避免竟态，死锁以及很多其他共享状态的并发性问题。</li>
<li>此外，在等待访问共享数据结构时，线程之间的互相等待将会丢失部分并行性。许多并发数据结构是阻塞的，意味着在任何一个时间只有一个或者很少的线程能够访问。这样会导致在这些共享数据结构上出现竞争状态。在执行需要访问共享数据结构部分的代码时，高竞争基本上会导致执行时出现一定程度的串行化。</li>
<li>现在的非阻塞并发算法也许可以降低竞争并提升性能，但是非阻塞算法的实现比较困难。</li>
<li>可持久化的数据结构是另一种选择。在修改的时候，可持久化的数据结构总是保护它的前一个版本不受影响。因此，如果多个线程指向同一个可持久化的数据结构，并且其中一个线程进行了修改，进行修改的线程会获得一个指向新结构的引用。所有其他线程保持对旧结构的引用，旧结构没有被修改并且因此保证一致性。Scala编程包含几个持久化数据结构。<br>【注：这里的可持久化数据结构不是指持久化存储，而是一种数据结构，比如Java中的String类，以及CopyOnWriteArrayList类，具体可参考】<br>虽然可持久化的数据结构在解决共享数据结构的并发修改时显得很优雅，但是可持久化的数据结构的表现往往不尽人意。</li>
</ul>
<h4 id="无状态的工作者"><a href="#无状态的工作者" class="headerlink" title="无状态的工作者"></a>无状态的工作者</h4><p>共享状态能够被系统中得其他线程修改。所以工作者在每次需要的时候必须重读状态，以确保每次都能访问到最新的副本，不管共享状态是保存在内存中的还是在外部数据库中。工作者无法在内部保存这个状态（但是每次需要的时候可以重读）称为无状态的。</p>
<p>每次都重读需要的数据，将会导致速度变慢，特别是状态保存在外部数据库中的时候。</p>
<h4 id="任务顺序是不确定的"><a href="#任务顺序是不确定的" class="headerlink" title="任务顺序是不确定的"></a>任务顺序是不确定的</h4><p>并行工作者模式的另一个缺点是，作业执行顺序是不确定的。无法保证哪个作业最先或者最后被执行。作业A可能在作业B之前就被分配工作者了，但是作业B反而有可能在作业A之前执行。</p>
<p>并行工作者模式的这种非确定性的特性，使得很难在任何特定的时间点推断系统的状态。这也使得它也更难（如果不是不可能的话）保证一个作业在其他作业之前被执行。</p>
<h2 id="流水线模式"><a href="#流水线模式" class="headerlink" title="流水线模式"></a>流水线模式</h2><p>第二种并发模型我们称之为流水线并发模型。我之所以选用这个名字，只是为了配合“并行工作者”的隐喻。其他开发者可能会根据平台或社区选择其他称呼（比如说反应器系统，或事件驱动系统）。下图表示一个流水线并发模型：<br><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png" alt=""><br>似于工厂中生产线上的工人们那样组织工作者。每个工作者只负责作业中的部分工作。当完成了自己的这部分工作时工作者会将作业转发给下一个工作者。每个工作者在自己的线程中运行，并且不会和其他工作者共享状态。有时也被成为无共享并行模型。</p>
<p>通常使用非阻塞的IO来设计使用流水线并发模型的系统。非阻塞IO意味着，一旦某个工作者开始一个IO操作的时候（比如读取文件或从网络连接中读取数据），这个工作者不会一直等待IO操作的结束。IO操作速度很慢，所以等待IO操作结束很浪费CPU时间。此时CPU可以做一些其他事情。当IO操作完成的时候，IO操作的结果（比如读出的数据或者数据写完的状态）被传递给下一个工作者。</p>
<p>有了非阻塞IO，就可以使用IO操作确定工作者之间的边界。工作者会尽可能多运行直到遇到并启动一个IO操作。然后交出作业的控制权。当IO操作完成的时候，在流水线上的下一个工作者继续进行操作，直到它也遇到并启动一个IO操作。<br><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png" alt=""><br>在实际应用中，作业有可能不会沿着单一流水线进行。由于大多数系统可以执行多个作业，作业从一个工作者流向另一个工作者取决于作业需要做的工作。在实际中可能会有多个不同的虚拟流水线同时运行。这是现实当中作业在流水线系统中可能的移动情况：<br><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png" alt=""><br>作业甚至也有可能被转发到超过一个工作者上并发处理。比如说，作业有可能被同时转发到作业执行器和作业日志器。下图说明了三条流水线是如何通过将作业转发给同一个工作者（中间流水线的最后一个工作者）来完成作业:<br><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png" alt=""><br>流水线有时候比这个情况更加复杂。</p>
<h3 id="反应器，事件驱动系统"><a href="#反应器，事件驱动系统" class="headerlink" title="反应器，事件驱动系统"></a>反应器，事件驱动系统</h3><p>采用流水线并发模型的系统有时候也称为反应器系统或事件驱动系统。系统内的工作者对系统内出现的事件做出反应，这些事件也有可能来自于外部世界或者发自其他工作者。事件可以是传入的HTTP请求，也可以是某个文件成功加载到内存中等。在写这篇文章的时候，已经有很多有趣的反应器/事件驱动平台可以使用了，并且不久的将来会有更多。比较流行的似乎是这几个：</p>
<ul>
<li>Vert.x</li>
<li>AKKa</li>
<li>Node.JS(JavaScript)</li>
</ul>
<h3 id="Actors-和-Channels"><a href="#Actors-和-Channels" class="headerlink" title="Actors 和 Channels"></a>Actors 和 Channels</h3><p>Actors 和 channels 是两种比较类似的流水线（或反应器/事件驱动）模型。<br>在Actor模型中每个工作者被称为actor。Actor之间可以直接异步地发送和处理消息。Actor可以被用来实现一个或多个像前文描述的那样的作业处理流水线。下图给出了Actor模型：<br><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-7.png" alt=""><br>而在Channel模型中，工作者之间不直接进行通信。相反，它们在不同的通道中发布自己的消息（事件）。其他工作者们可以在这些通道上监听消息，发送者无需知道谁在监听。下图给出了Channel模型：<br><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-8.png" alt=""><br>在写这篇文章的时候，channel模型对于我来说似乎更加灵活。一个工作者无需知道谁在后面的流水线上处理作业。只需知道作业（或消息等）需要转发给哪个通道。通道上的监听者可以随意订阅或者取消订阅，并不会影响向这个通道发送消息的工作者。这使得工作者之间具有松散的耦合。</p>
<h3 id="流水线模型的优点"><a href="#流水线模型的优点" class="headerlink" title="流水线模型的优点"></a>流水线模型的优点</h3><p>相比并行工作者模型，流水线并发模型具有几个优点，在接下来的章节中我会介绍几个最大的优点。</p>
<h4 id="无需共享的状态"><a href="#无需共享的状态" class="headerlink" title="无需共享的状态"></a>无需共享的状态</h4><p>工作者之间无需共享状态，意味着实现的时候无需考虑所有因并发访问共享对象而产生的并发性问题。这使得在实现工作者的时候变得非常容易。在实现工作者的时候就好像是单个线程在处理工作-基本上是一个单线程的实现。</p>
<h4 id="有状态的工作者"><a href="#有状态的工作者" class="headerlink" title="有状态的工作者"></a>有状态的工作者</h4><p>当工作者知道了没有其他线程可以修改它们的数据，工作者可以变成有状态的。对于有状态，我是指，它们可以在内存中保存它们需要操作的数据，只需在最后将更改写回到外部存储系统。因此，有状态的工作者通常比无状态的工作者具有更高的性能。</p>
<h4 id="Hardware-Conformity"><a href="#Hardware-Conformity" class="headerlink" title="Hardware Conformity"></a>Hardware Conformity</h4><p>单线程代码在整合底层硬件的时候往往具有更好的优势。首先，当能确定代码只在单线程模式下执行的时候，通常能够创建更优化的数据结构和算法。</p>
<p>其次，像前文描述的那样，单线程有状态的工作者能够在内存中缓存数据。在内存中缓存数据的同时，也意味着数据很有可能也缓存在执行这个线程的CPU的缓存中。这使得访问缓存的数据变得更快。</p>
<h4 id="合理的作业顺序"><a href="#合理的作业顺序" class="headerlink" title="合理的作业顺序"></a>合理的作业顺序</h4><p>基于流水线并发模型实现的并发系统，在某种程度上是有可能保证作业的顺序的。作业的有序性使得它更容易地推出系统在某个特定时间点的状态。更进一步，你可以将所有到达的作业写入到日志中去。一旦这个系统的某一部分挂掉了，该日志就可以用来重头开始重建系统当时的状态。按照特定的顺序将作业写入日志，并按这个顺序作为有保障的作业顺序。<br>实现一个有保障的作业顺序是不容易的，但往往是可行的。如果可以，它将大大简化一些任务，例如备份、数据恢复、数据复制等，这些都可以通过日志文件来完成。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>流水线并发模型最大的缺点是作业的执行往往分布到多个工作者上，并因此分布到项目中的多个类上。这样导致在追踪某个作业到底被什么代码执行时变得困难。</p>
<p>同样，这也加大了代码编写的难度。有时会将工作者的代码写成回调处理的形式。若在代码中嵌入过多的回调处理，往往会出现所谓的回调地狱（callback hell）现象。所谓回调地狱，就是意味着在追踪代码在回调过程中到底做了什么，以及确保每个回调只访问它需要的数据的时候，变得非常困难</p>
<p>使用并行工作者模型可以简化这个问题。你可以打开工作者的代码，从头到尾优美的阅读被执行的代码。当然并行工作者模式的代码也可能同样分布在不同的类中，但往往也能够很容易的从代码中分析执行的顺序。</p>
<h2 id="函数式并行（Functional-Parallelism）"><a href="#函数式并行（Functional-Parallelism）" class="headerlink" title="函数式并行（Functional Parallelism）"></a>函数式并行（Functional Parallelism）</h2><p>第三种并发模型是函数式并行模型，这是也最近（2015）讨论的比较多的一种模型。函数式并行的基本思想是采用函数调用实现程序。函数可以看作是”代理人（agents）“或者”actor“，函数之间可以像流水线模型（AKA 反应器或者事件驱动系统）那样互相发送消息。某个函数调用另一个函数，这个过程类似于消息发送。</p>
<p>函数都是通过拷贝来传递参数的，所以除了接收函数外没有实体可以操作数据。这对于避免共享数据的竞态来说是很有必要的。同样也使得函数的执行类似于原子操作。每个函数调用的执行独立于任何其他函数的调用。</p>
<p>一旦每个函数调用都可以独立的执行，它们就可以分散在不同的CPU上执行了。这也就意味着能够在多处理器上并行的执行使用函数式实现的算法。</p>
<p>Java7中的java.util.concurrent包里包含的ForkAndJoinPool能够帮助我们实现类似于函数式并行的一些东西。而Java8中并行streams能够用来帮助我们并行的迭代大型集合。记住有些开发者对ForkAndJoinPool进行了批判（你可以在我的ForkAndJoinPool教程里面看到批评的链接）。</p>
<p>函数式并行里面最难的是确定需要并行的那个函数调用。跨CPU协调函数调用需要一定的开销。某个函数完成的工作单元需要达到某个大小以弥补这个开销。如果函数调用作用非常小，将它并行化可能比单线程、单CPU执行还慢。</p>
<p>我个人认为（可能不太正确），你可以使用反应器或者事件驱动模型实现一个算法，像函数式并行那样的方法实现工作的分解。使用事件驱动模型可以更精确的控制如何实现并行化（我的观点）。</p>
<p>此外，将任务拆分给多个CPU时协调造成的开销，仅仅在该任务是程序当前执行的唯一任务时才有意义。但是，如果当前系统正在执行多个其他的任务时（比如web服务器，数据库服务器或者很多其他类似的系统），将单个任务进行并行化是没有意义的。不管怎样计算机中的其他CPU们都在忙于处理其他任务，没有理由用一个慢的、函数式并行的任务去扰乱它们。使用流水线（反应器）并发模型可能会更好一点，因为它开销更小（在单线程模式下顺序执行）同时能更好的与底层硬件整合。</p>
<h2 id="使用那种并发模型最好？"><a href="#使用那种并发模型最好？" class="headerlink" title="使用那种并发模型最好？"></a>使用那种并发模型最好？</h2><p>所以，用哪种并发模型更好呢?<br>通常情况下，这个答案取决于你的系统打算做什么。如果你的作业本身就是并行的、独立的并且没有必要共享状态，你可能会使用并行工作者模型去实现你的系统。虽然许多作业都不是自然并行和独立的。对于这种类型的系统，我相信使用流水线并发模型能够更好的发挥它的优势，而且比并行工作者模型更有优势。<br>你甚至不用亲自编写所有流水线模型的基础结构。像Vert.x这种现代化的平台已经为你实现了很多。我也会去为探索如何设计我的下一个项目，使它运行在像Vert.x这样的优秀平台上。我感觉Java EE已经没有任何优势了。</p>
<h1 id="创建并运行java线程"><a href="#创建并运行java线程" class="headerlink" title="创建并运行java线程"></a>创建并运行java线程</h1><p>编写线程运行时执行的代码有两种方式：一种是创建Thread子类的一个实例并重写run方法，第二种是创建类的时候实现Runnable接口。接下来我们会具体讲解这两种方法：</p>
<h2 id="创建Thread的子类"><a href="#创建Thread的子类" class="headerlink" title="创建Thread的子类"></a>创建Thread的子类</h2><p>创建Thread子类的一个实例并重写run方法，run方法会在调用start()方法之后被执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">     System.out.println(<span class="string">"MyThread running"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以用如下方式创建并运行上述Thread子类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</div><div class="line">myTread.start();</div></pre></td></tr></table></figure>
<p>一旦线程启动后start方法就会立即返回，而不会等待到run方法执行完毕才返回。就好像run方法是在另外一个cpu上执行一样。当run方法执行后，将会打印出字符串MyThread running。(?)<br>也可以像</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread thread = <span class="keyword">new</span> Thread()&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">     System.out.println(<span class="string">"Thread Running"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line">thread.start();</div></pre></td></tr></table></figure>
<h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><p> 第二种编写线程执行代码的方式是新建一个实现了java.lang.Runnable接口的类的实例，实例中的方法可以被线程调用。下面给出例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"MyRunnable running"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了使线程能够执行run()方法，需要在Thread类的构造函数中传入 MyRunnable的实例对象。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</div><div class="line">thread.start();</div></pre></td></tr></table></figure>
<p>当线程运行时，它将会调用实现了Runnable接口的run方法。上例中将会打印出”MyRunnable running”。<br>同样，也可以创建一个实现了Runnable接口的匿名类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Runnable myRunnable = <span class="keyword">new</span> Runnable()&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">     System.out.println(<span class="string">"Runnable running"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">Thread thread = <span class="keyword">new</span> Thread(myRunnable);</div><div class="line">thread.start();</div></pre></td></tr></table></figure>
<h2 id="创建子类还是实现Runnable接口？"><a href="#创建子类还是实现Runnable接口？" class="headerlink" title="创建子类还是实现Runnable接口？"></a>创建子类还是实现Runnable接口？</h2><p>对于这两种方式哪种好并没有一个确定的答案，它们都能满足要求。就我个人意见，我更倾向于实现Runnable接口这种方法。因为线程池可以有效的管理实现了Runnable接口的线程，如果线程池满了，新的线程就会排队等候执行，直到线程池空闲出来为止。而如果线程是通过实现Thread子类实现的，这将会复杂一些。</p>
<p>有时我们要同时融合实现Runnable接口和Thread子类两种方式。例如，实现了Thread子类的实例可以执行多个实现了Runnable接口的线程。一个典型的应用就是线程池。</p>
<h2 id="常见错误：调用run-方法而非start-方法"><a href="#常见错误：调用run-方法而非start-方法" class="headerlink" title="常见错误：调用run()方法而非start()方法"></a>常见错误：调用run()方法而非start()方法</h2><p>创建并运行一个线程所犯的常见错误是调用线程的run()方法而非start()方法.<br>但是，事实上,run()方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了,。想要让创建的新线程执行run()方法，必须调用新线程的start方法。<br>当创建一个线程的时候，可以给线程起一个名字。它有助于我们区分不同的线程。例如：如果有多个线程写入System.out，我们就能够通过线程名容易的找出是哪个线程正在输出。例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</div><div class="line">Thread thread = <span class="keyword">new</span> Thread(runnable, <span class="string">"New Thread"</span>);</div><div class="line">thread.start();</div><div class="line">System.out.println(thread.getName());</div></pre></td></tr></table></figure>
<p>需要注意的是，因为MyRunnable并非Thread的子类，所以MyRunnable类并没有getName()方法。可以通过以下方式得到当前线程的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread.currentThread();</div></pre></td></tr></table></figure>
<p>因此，通过如下代码可以得到当前线程的名字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String threadName = Thread.currentThread().getName();</div></pre></td></tr></table></figure>
<h2 id="线程代码举例："><a href="#线程代码举例：" class="headerlink" title="线程代码举例："></a>线程代码举例：</h2><p>这里是一个小小的例子。首先输出执行main()方法线程名字。这个线程JVM分配的。然后开启10个线程，命名为1~10。每个线程输出自己的名字后就退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExample</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">     System.out.println(Thread.currentThread().getName());</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</div><div class="line">         <span class="keyword">new</span> Thread(<span class="string">""</span> + i)&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">             System.out.println(<span class="string">"Thread: "</span> + getName() + <span class="string">"running"</span>);</div><div class="line">            &#125;</div><div class="line">         &#125;.start();</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，尽管启动线程的顺序是有序的，但是执行的顺序并非是有序的。也就是说，1号线程并不一定是第一个将自己名字输出到控制台的线程。这是因为线程是并行执行而非顺序的。Jvm和操作系统一起决定了线程的执行顺序，他和线程的启动顺序并非一定是一致的。</p>
<h1 id="竞态条件与临界区"><a href="#竞态条件与临界区" class="headerlink" title="竞态条件与临界区"></a>竞态条件与临界区</h1><p>在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。</p>
<p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。在临界区中使用适当的同步就可以避免竞态条件。</p>
<h1 id="线程安全与共享资源"><a href="#线程安全与共享资源" class="headerlink" title="线程安全与共享资源"></a>线程安全与共享资源</h1><p>允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，了解Java线程执行时共享了什么资源很重要。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。下面是基础类型的局部变量的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">long</span> threadSafeInt = <span class="number">0</span>;</div><div class="line">  threadSafeInt++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="局部的对象引用"><a href="#局部的对象引用" class="headerlink" title="局部的对象引用"></a>局部的对象引用</h2><p>对象的局部引用和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中。如果在某个方法中创建的对象不会逃逸出（译者注：即该对象不会被其它方法获得，也不会被非局部变量引用到）该方法，那么它就是线程安全的。实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。下面是一个线程安全的局部引用样例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span></span>&#123;</div><div class="line">  LocalObject localObject = <span class="keyword">new</span> LocalObject();</div><div class="line">  localObject.callMethod();</div><div class="line">  method2(localObject);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(LocalObject localObject)</span></span>&#123;</div><div class="line">  localObject.setValue(<span class="string">"value"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>样例中LocalObject对象没有被方法返回，也没有被传递给someMethod()方法外的对象。每个执行someMethod()的线程都会创建自己的LocalObject对象，并赋值给localObject引用。因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是线程安全的。当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了。</p>
<h2 id="对象成员"><a href="#对象成员" class="headerlink" title="对象成员"></a>对象成员</h2><p>对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。下面是一个样例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotThreadSafe</span></span>&#123;</div><div class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">add</span><span class="params">(String text)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.builder.append(text);</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">NotThreadSafe sharedInstance = <span class="keyword">new</span> NotThreadSafe();</div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(sharedInstance)).start();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(sharedInstance)).start();</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">  NotThreadSafe instance = <span class="keyword">null</span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(NotThreadSafe instance)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.instance = instance;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.instance.add(<span class="string">"some text"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意两个MyRunnable共享了同一个NotThreadSafe对象。因此，当它们调用add()方法时会造成竞态条件。</p>
<p>当然，如果这两个线程在不同的NotThreadSafe实例上调用call()方法，就不会导致竞态条件。下面是稍微修改后的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="keyword">new</span> NotThreadSafe())).start();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="keyword">new</span> NotThreadSafe())).start();</div></pre></td></tr></table></figure>
<h2 id="线程控制逃逸规则"><a href="#线程控制逃逸规则" class="headerlink" title="线程控制逃逸规则"></a>线程控制逃逸规则</h2><p>线程控制逃逸规则可以帮助你判断代码中对某些资源的访问是否是线程安全的。</p>
<blockquote>
<p>如果一个资源的创建，使用，销毁都在同一个线程内完成，<br>且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。</p>
</blockquote>
<p>资源可以是对象，数组，文件，数据库连接，套接字等等。Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象。</p>
<p>即使对象本身线程安全，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不再是线程安全的了。比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的。比如，2个线程执行如下代码：</p>
<blockquote>
<p>检查记录X是否存在，如果不存在，插入X</p>
</blockquote>
<p>如果两个线程同时执行，而且碰巧检查的是同一个记录，那么两个线程最终可能都插入了记录：</p>
<blockquote>
<p>线程1检查记录X是否存在。检查结果：不存在<br>线程2检查记录X是否存在。检查结果：不存在<br>线程1插入记录X<br>线程2插入记录X</p>
</blockquote>
<p>同样的问题也会发生在文件或其他共享资源上。因此，<strong>区分某个线程控制的对象是资源【】本身还是仅仅到某个资源的【引用】很重要。</strong></p>
<h1 id="线程安全及不可变性"><a href="#线程安全及不可变性" class="headerlink" title="线程安全及不可变性"></a>线程安全及不可变性</h1><p>当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了写操作，才会产生竞态条件。多个线程同时读同一个资源不会产生竞态条件。</p>
<p>我们可以通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableValue</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意ImmutableValue类的成员变量value是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建，value变量就不能再被修改，这就是不可变性。但你可以通过getValue()方法读取这个变量的值。<br>（译者注：注意，“不变”（Immutable）和“只读”（Read Only）是不同的。当一个变量是“只读”时，变量的值不能直接改变，但是可以在其它变量发生改变的时候发生改变。比如，一个人的出生年月日是“不变”属性，而一个人的年龄便是“只读”属性，但是不是“不变”属性。随着时间的变化，一个人的年龄会随之发生变化，而一个人的出生年月日则不会变化。这就是“不变”和“只读”的区别。（摘自《Java与模式》第34章））<br>如果你需要对ImmutableValue类的实例进行操作，可以通过得到value变量后创建一个新的实例来实现，下面是一个对value变量进行加法操作的示例：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ImmutableValue</span>&#123;</span></div><div class="line">    private int value = <span class="number">0</span>;</div><div class="line"></div><div class="line">    public ImmutableValue(int value)&#123;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getValue()&#123;</div><div class="line">        <span class="keyword">return</span> this.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ImmutableValue add(int valueToAdd)&#123;</div><div class="line">        <span class="keyword">return</span> new ImmutableValue(this.value + valueToAdd);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>请注意add()方法以加法操作的结果作为一个新的ImmutableValue类实例返回，而不是直接对它自己的value变量进行操作。<br><strong>引用不是线程安全的！</strong><br>重要的是要记住，即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的。看这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> Calculator&#123;</div><div class="line">    <span class="keyword">private</span> ImmutableValue currentValue = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ImmutableValue <span class="title">getValue</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> currentValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(ImmutableValue newValue)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.currentValue = newValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.currentValue = <span class="keyword">this</span>.currentValue.add(newValue);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。换句话说：ImmutableValue类是线程安全的，但使用它的类不是。当尝试通过不可变性去获得线程安全时，这点是需要牢记的。</p>
<p>要使Calculator类实现线程安全，将getValue()、setValue()和add()方法都声明为同步方法即可。</p>
<h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><p>方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。</p>
<p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。</p>
<p>堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。</p>
<p>下面这张图演示了调用栈和本地变量存放在线程栈上，对象存放在堆上。<br><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" alt=""></p>
<p>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</p>
<p>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</p>
<p>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。</p>
<p>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</p>
<p>静态成员变量跟随着类定义一起也存放在堆上。</p>
<p>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。</p>
<p>下图演示了上面提到的点：<br><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png" alt=""><br>两个线程拥有一些列的本地变量。其中一个本地变量（Local Variable 2）执行堆上的一个共享对象（Object 3）。这两个线程分别拥有同一个对象的不同引用。这些引用都是本地变量，因此存放在各自线程的线程栈上。这两个不同的引用指向堆上同一个对象。</p>
<p>注意，这个共享对象（Object 3）持有Object2和Object4一个引用作为其成员变量（如图中Object3指向Object2和Object4的箭头）。通过在Object3中这些成员变量引用，这两个线程就可以访问Object2和Object4。</p>
<p>这张图也展示了指向堆上两个不同对象的一个本地变量。在这种情况下，指向两个不同对象的引用不是同一个对象。理论上，两个线程都可以访问Object1和Object5，如果两个线程都拥有两个对象的引用。但是在上图中，每一个线程仅有一个引用指向两个对象其中之一。</p>
<p>因此，什么类型的Java代码会导致上面的内存图呢？如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class MyRunnable implements <span class="title">Runnable</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        methodOne();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> localVariable1 = <span class="number">45</span>;</div><div class="line"></div><div class="line">        MySharedObject localVariable2 =</div><div class="line">            MySharedObject.sharedInstance;</div><div class="line"></div><div class="line">        <span class="comment">//... do more with local variables.</span></div><div class="line"></div><div class="line">        methodTwo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</div><div class="line">        Integer localVariable1 = <span class="keyword">new</span> Integer(<span class="number">99</span>);</div><div class="line"></div><div class="line">        <span class="comment">//... do more with local variable.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySharedObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//static variable pointing to instance of MySharedObject</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySharedObject sharedInstance =</div><div class="line">        <span class="keyword">new</span> MySharedObject();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//member variables pointing to two objects on the heap</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> Integer object2 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</div><div class="line">    <span class="keyword">public</span> Integer object4 = <span class="keyword">new</span> Integer(<span class="number">44</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> member1 = <span class="number">12345</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> member1 = <span class="number">67890</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果两个线程同时执行run()方法，就会出现上图所示的情景。run()方法调用methodOne()方法，methodOne()调用methodTwo()方法。</p>
<p>methodOne()声明了一个原始类型的本地变量和一个引用类型的本地变量。</p>
<p>每个线程执行methodOne()都会在它们对应的线程栈上创建localVariable1和localVariable2的私有拷贝。localVariable1变量彼此完全独立，仅“生活”在每个线程的线程栈上。一个线程看不到另一个线程对它的localVariable1私有拷贝做出的修改。</p>
<p>每个线程执行methodOne()时也将会创建它们各自的localVariable2拷贝。然而，两个localVariable2的不同拷贝都指向堆上的同一个对象。代码中通过一个静态变量设置localVariable2指向一个对象引用。仅存在一个静态变量的一份拷贝，这份拷贝存放在堆上。因此，localVariable2的两份拷贝都指向由MySharedObject指向的静态变量的同一个实例。MySharedObject实例也存放在堆上。它对应于上图中的Object3。</p>
<p>注意，MySharedObject类也包含两个成员变量。这些成员变量随着这个对象存放在堆上。这两个成员变量指向另外两个Integer对象。这些Integer对象对应于上图中的Object2和Object4.</p>
<p>注意，methodTwo()创建一个名为localVariable的本地变量。这个成员变量是一个指向一个Integer对象的对象引用。这个方法设置localVariable1引用指向一个新的Integer实例。在执行methodTwo方法时，localVariable1引用将会在每个线程中存放一份拷贝。这两个Integer对象实例化将会被存储堆上，但是每次执行这个方法时，这个方法都会创建一个新的Integer对象，两个线程执行这个方法将会创建两个不同的Integer实例。methodTwo方法创建的Integer对象对应于上图中的Object1和Object5。</p>
<p>还有一点，MySharedObject类中的两个long类型的成员变量是原始类型的。因为，这些变量是成员变量，所以它们任然随着该对象存放在堆上，仅有本地变量存放在线程栈上.</p>
<h2 id="Java内存模型和硬件内存架构之间的桥接"><a href="#Java内存模型和硬件内存架构之间的桥接" class="headerlink" title="Java内存模型和硬件内存架构之间的桥接"></a>Java内存模型和硬件内存架构之间的桥接</h2><p>硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示：<br><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" alt=""><br>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。主要包括如下两个方面：</p>
<ul>
<li>线程对共享变量修改的可见性</li>
<li>当读，写和检查共享变量时出现race conditions(竞态)</li>
</ul>
<p>下面我们专门来解释以下这两个问题。</p>
<h2 id="共享对象可见性"><a href="#共享对象可见性" class="headerlink" title="共享对象可见性"></a>共享对象可见性</h2><p>如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不接见的。<br>想象一下，共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。<br>下图示意了这种情形。跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去。<br><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" alt=""><br>解决这个问题你可以使用Java中的volatile关键字。volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。</p>
<h2 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h2><p>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。</p>
<p>想象一下，如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增在了两个，每个CPU缓存中一次。</p>
<p>如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。</p>
<p>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。下图演示了上面描述的情况：<br><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" alt=""><br>解决这个问题可以使用Java同步块。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p>
<h1 id="java同步块"><a href="#java同步块" class="headerlink" title="java同步块"></a>java同步块</h1><p>ava 同步块（synchronized block）用来标记方法或者代码块是同步的。Java同步块用来避免竞争。本文介绍以下内容：</p>
<ul>
<li>Java同步关键字（synchronzied）</li>
<li>实例方法同步</li>
<li>静态方法同步</li>
<li>实例方法中同步块</li>
<li>静态方法中同步块</li>
<li>Java同步示例</li>
</ul>
<h2 id="Java-同步关键字（synchronized）"><a href="#Java-同步关键字（synchronized）" class="headerlink" title="Java 同步关键字（synchronized）"></a>Java 同步关键字（synchronized）</h2><p>Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</p>
<p>有四种不同的同步块：</p>
<ul>
<li>实例方法</li>
<li>静态方法</li>
<li>实例方法中的同步块</li>
<li>静态方法中的同步块<br>上述同步块都同步在不同对象上。实际需要那种同步块视具体情况而定。</li>
</ul>
<h2 id="实例方法同步"><a href="#实例方法同步" class="headerlink" title="实例方法同步"></a>实例方法同步</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.count += value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。</p>
<h2 id="静态方法同步"><a href="#静态方法同步" class="headerlink" title="静态方法同步"></a>静态方法同步</h2><p>静态方法同步和实例方法同步方法一样，也使用synchronized 关键字。Java静态方法同步如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</div><div class="line">    count += value;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>同样，这里synchronized 关键字告诉Java这个方法是同步的。</p>
<p>静态方法的同步是指同步在该方法所在的类对象上。因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。</p>
<p>对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。</p>
<h2 id="实例方法中的同步块"><a href="#实例方法中的同步块" class="headerlink" title="实例方法中的同步块"></a>实例方法中的同步块</h2><p>有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。</p>
<p>在非同步的Java方法中的同步块的例子如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">       <span class="keyword">this</span>.count += value;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>示例使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样。</p>
<p>注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。</p>
<p>一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。<br>下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">log1</span><span class="params">(String msg1, String msg2)</span></span>&#123;</div><div class="line">      log.writeln(msg1);</div><div class="line">      log.writeln(msg2);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log2</span><span class="params">(String msg1, String msg2)</span></span>&#123;</div><div class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">         log.writeln(msg1);</div><div class="line">         log.writeln(msg2);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。</p>
<p>如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。</p>
<h2 id="静态方法中的同步块"><a href="#静态方法中的同步块" class="headerlink" title="静态方法中的同步块"></a>静态方法中的同步块</h2><p>和上面类似，下面是两个静态方法同步的例子。这些方法同步在该方法所属的类对象上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">log1</span><span class="params">(String msg1, String msg2)</span></span>&#123;</div><div class="line">       log.writeln(msg1);</div><div class="line">       log.writeln(msg2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log2</span><span class="params">(String msg1, String msg2)</span></span>&#123;</div><div class="line">       <span class="keyword">synchronized</span>(MyClass.class)&#123;</div><div class="line">          log.writeln(msg1);</div><div class="line">          log.writeln(msg2);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这两个方法不允许同时被线程访问。</p>
<p>如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。</p>
<h2 id="Java同步实例"><a href="#Java同步实例" class="headerlink" title="Java同步实例"></a>Java同步实例</h2><p>在下面例子中，启动了两个线程，都调用Counter类同一个实例的add方法。因为同步在该方法所属的实例上，所以同时只能有一个线程访问该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</div><div class="line">     <span class="keyword">long</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> value)</span></span>&#123;</div><div class="line">       <span class="keyword">this</span>.count += value;</div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">protected</span> Counter counter = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">CounterThread</span><span class="params">(Counter counter)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.counter = counter;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</div><div class="line">           counter.add(i);</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">      Counter counter = <span class="keyword">new</span> Counter();</div><div class="line">      Thread  threadA = <span class="keyword">new</span> CounterThread(counter);</div><div class="line">      Thread  threadB = <span class="keyword">new</span> CounterThread(counter);</div><div class="line"></div><div class="line">      threadA.start();</div><div class="line">      threadB.start();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>创建了两个线程。他们的构造器引用同一个Counter实例。Counter.add方法是同步在实例上，是因为add方法是实例方法并且被标记上synchronized关键字。因此每次只允许一个线程调用该方法。另外一个线程必须要等到第一个线程退出add()方法时，才能继续执行方法。</p>
<p>如果两个线程引用了两个不同的Counter实例，那么他们可以同时调用add()方法。这些方法调用了不同的对象，因此这些方法也就同步在不同的对象上。这些方法调用将不会被阻塞。如下面这个例子所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">     Counter counterA = <span class="keyword">new</span> Counter();</div><div class="line">     Counter counterB = <span class="keyword">new</span> Counter();</div><div class="line">     Thread  threadA = <span class="keyword">new</span> CounterThread(counterA);</div><div class="line">     Thread  threadB = <span class="keyword">new</span> CounterThread(counterB);</div><div class="line"></div><div class="line">     threadA.start();</div><div class="line">     threadB.start();</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p>
<p>例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。本文将讲解以下几个JAVA线程间通信的主题：<br>1、通过共享对象通信<br>2、忙等待<br>3、wait(),notify()和notifyAll()<br>4、丢失的信号<br>5、假唤醒<br>6、多线程等待相同信号<br>7、不要对常量字符串或全局对象调用wait()</p>
<h2 id="通过共享对象通信"><a href="#通过共享对象通信" class="headerlink" title="通过共享对象通信"></a>通过共享对象通信</h2><p>线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySignal</span></span>&#123;</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> hasDataToProcess = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasDataToProcess</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hasDataToProcess;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setHasDataToProcess</span><span class="params">(<span class="keyword">boolean</span> hasData)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.hasDataToProcess = hasData;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里，它和MySignal实例是分开存放的。</p>
<h2 id="忙等待-Busy-Wait"><a href="#忙等待-Busy-Wait" class="headerlink" title="忙等待(Busy Wait)"></a>忙等待(Busy Wait)</h2><p>准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected MySignal sharedSignal = ...</div><div class="line">...</div><div class="line"><span class="keyword">while</span>(!sharedSignal.hasDataToProcess())&#123;</div><div class="line">  <span class="regexp">//do</span> nothing... busy waiting</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="wait-notify-和notifyAll"><a href="#wait-notify-和notifyAll" class="headerlink" title="wait(),notify()和notifyAll()"></a>wait(),notify()和notifyAll()</h2><p>忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。</p>
<p>Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。</p>
<p>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。以下是MySingal的修改版本——使用了wait()和notify()的MyWaitNotify：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorObject</span></span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify</span></span>&#123;</div><div class="line"></div><div class="line">  MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</div><div class="line">      <span class="keyword">try</span>&#123;</div><div class="line">        myMonitorObject.wait();</div><div class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</div><div class="line">      myMonitorObject.notify();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等待线程将调用doWait()，而唤醒线程将调用doNotify()。当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行（校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。</p>
<p>如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()。否则，会抛出IllegalMonitorStateException异常。</p>
<p><em>（校注：JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept，参考JVM源码的 1422行。）</em></p>
<p>但是，这怎么可能？等待线程在同步块里面执行的时候，不是一直持有监视器对象（myMonitor对象）的锁吗？等待线程不能阻塞唤醒线程进入doNotify()的同步块吗？答案是：的确不能。一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用wait()或者notify()。</p>
<p>一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。</p>
<h2 id="丢失的信号（Missed-Signals）"><a href="#丢失的信号（Missed-Signals）" class="headerlink" title="丢失的信号（Missed Signals）"></a>丢失的信号（Missed Signals）</h2><p>notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。<br>为了避免丢失信号，必须把它们保存在信号类里。在MyWaitNotify的例子中，通知信号应被存储在MyWaitNotify实例的一个成员变量里。以下是MyWaitNotify的修改版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify2</span></span>&#123;</div><div class="line"></div><div class="line">  MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</div><div class="line">  <span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</div><div class="line">      <span class="keyword">if</span>(!wasSignalled)&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">          myMonitorObject.wait();</div><div class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//clear signal and continue running.</span></div><div class="line">      wasSignalled = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</div><div class="line">      wasSignalled = <span class="keyword">true</span>;</div><div class="line">      myMonitorObject.notify();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>留意doNotify()方法在调用notify()前把wasSignalled变量设为true。同时，留意doWait()方法在调用wait()前会检查wasSignalled变量。事实上，如果没有信号在前一次doWait()调用和这次doWait()调用之间的时间段里被接收到，它将只调用wait()。<br><em>（校注：为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。）</em></p>
<h2 id="假唤醒"><a href="#假唤醒" class="headerlink" title="假唤醒"></a>假唤醒</h2><p>由于莫名其妙的原因（？？？？），线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。无端端地醒过来了。</p>
<p>如果在MyWaitNotify2的doWait()方法里发生了假唤醒，等待线程即使没有收到正确的信号，也能够执行后续的操作。这可能导致你的应用程序出现严重问题。</p>
<p>为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁（校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。以下MyWaitNotify2的修改版本展示了这点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify3</span></span>&#123;</div><div class="line"></div><div class="line">  MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</div><div class="line">  <span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</div><div class="line">      <span class="keyword">while</span>(!wasSignalled)&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">          myMonitorObject.wait();</div><div class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//clear signal and continue running.</span></div><div class="line">      wasSignalled = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</div><div class="line">      wasSignalled = <span class="keyword">true</span>;</div><div class="line">      myMonitorObject.notify();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>留意wait()方法是在while循环里，而不在if表达式里。如果等待线程没有收到信号就唤醒，wasSignalled变量将变为false,while循环会再执行一次，促使醒来的线程回到等待状态。</p>
<h2 id="多个线程等待相同信号"><a href="#多个线程等待相同信号" class="headerlink" title="多个线程等待相同信号"></a>多个线程等待相同信号</h2><p>如果你有多个线程在等待，被notifyAll()唤醒，但只有一个被允许继续执行，使用while循环也是个好方法。每次只有一个线程可以获得监视器对象锁，意味着只有一个线程可以退出wait()调用并清除wasSignalled标志（设为false）。一旦这个线程退出doWait()的同步块，其他线程退出wait()调用，并在while循环里检查wasSignalled变量值。但是，这个标志已经被第一个唤醒的线程清除了，所以其余醒来的线程将回到等待状态，直到下次信号到来。</p>
<h1 id="Java-TheadLocal"><a href="#Java-TheadLocal" class="headerlink" title="Java TheadLocal"></a>Java TheadLocal</h1><p>Java中的ThreadLocal类可以让你<strong>创建的变量只被同一个线程进行读和写操作</strong>。因此，尽管有两个线程同时执行一段相同的代码，而且这段代码又有一个指向同一个ThreadLocal变量的引用，但是这两个线程依然不能看到彼此的ThreadLocal变量域。</p>
<p>1、创建一个ThreadLocal对象<br>2、访问ThreadLocal对象<br>3、ThreadLocal泛型<br>4、初始化ThreadLocal<br>5、Full ThreadLocal Example<br>6、InheritableThreadLocal</p>
<h2 id="创建一个ThreadLocal对象"><a href="#创建一个ThreadLocal对象" class="headerlink" title="创建一个ThreadLocal对象"></a>创建一个ThreadLocal对象</h2><p>如下所示，创建一个ThreadLocal变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal = <span class="keyword">new</span> ThreadLocal();</div></pre></td></tr></table></figure>
<p>你实例化了一个ThreadLocal对象。每个线程仅需要实例化一次即可。虽然不同的线程执行同一段代码时，访问同一个ThreadLocal变量，但是每个线程只能看到私有的ThreadLocal实例。所以不同的线程在给ThreadLocal对象设置不同的值时，他们也不能看到彼此的修改。</p>
<h2 id="访问ThreadLocal对象"><a href="#访问ThreadLocal对象" class="headerlink" title="访问ThreadLocal对象"></a>访问ThreadLocal对象</h2><p>一旦创建了一个ThreadLocal对象，你就可以通过以下方式来存储此对象的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myThreadLocal.set(<span class="string">"A thread local value"</span>);</div></pre></td></tr></table></figure>
<p>也可以直接读取一个ThreadLocal对象的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String threadLocalValue = (String) myThreadLocal.get();</div></pre></td></tr></table></figure>
<p>get()方法会返回一个Object对象，而set()方法则依赖一个Object对象参数。</p>
<h2 id="ThreadLocal泛型"><a href="#ThreadLocal泛型" class="headerlink" title="ThreadLocal泛型"></a>ThreadLocal泛型</h2><p>为了使get()方法返回值不用做强制类型转换，通常可以创建一个泛型化的ThreadLocal对象。以下就是一个泛型化的ThreadLocal示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal1 = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</div></pre></td></tr></table></figure>
<p>现在你可以存储一个字符串到ThreadLocal实例里，此外，当你从此ThreadLocal实例中获取值的时候，就不必要做强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myThreadLocal1.set(<span class="string">"Hello ThreadLocal"</span>);</div><div class="line">String threadLocalValues = myThreadLocal.get();</div></pre></td></tr></table></figure>
<h2 id="初始化ThreadLocal"><a href="#初始化ThreadLocal" class="headerlink" title="初始化ThreadLocal"></a>初始化ThreadLocal</h2><p>由于ThreadLocal对象的set()方法设置的值只对当前线程可见，那有什么方法可以为ThreadLocal对象设置的值对所有线程都可见。<br>为此，我们可以通过ThreadLocal子类的实现，并覆写initialValue()方法，就可以为ThreadLocal对象指定一个初始化值。如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;() &#123;</div><div class="line">   <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="string">"This is the initial value"</span>;</div><div class="line">   &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Full-ThreadLocal-Example"><a href="#Full-ThreadLocal-Example" class="headerlink" title="Full ThreadLocal Example"></a>Full ThreadLocal Example</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; threadLocal =</div><div class="line">               <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            threadLocal.set( (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>D) );</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            System.out.println(threadLocal.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyRunnable sharedRunnableInstance = <span class="keyword">new</span> MyRunnable();</div><div class="line"></div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</div><div class="line">        Thread thread2 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</div><div class="line"></div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line"></div><div class="line">        thread1.join(); <span class="comment">//wait for thread 1 to terminate</span></div><div class="line">        thread2.join(); <span class="comment">//wait for thread 2 to terminate</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面创建了两个线程共享一个MyRunnable实例。每个线程执行run()方法的时候，会给同一个ThreadLocal实例设置不同的值。如果调用set()方法的时候用synchronized关键字同步，而且不是一个ThreadLocal对象实例，那么第二个线程将会覆盖第一个线程所设置的值。</p>
<p>然而，由于是ThreadLocal对象，所以两个线程无法看到彼此的值。因此，可以设置或者获取不同的值。</p>
<h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><p>InheritableThreadLocal类是ThreadLocal的子类。为了解决ThreadLocal实例内部每个线程都只能看到自己的私有值，所以InheritableThreadLocal允许一个线程创建的所有子线程访问其父线程的值。</p>
<h1 id="线程通信（待补充）"><a href="#线程通信（待补充）" class="headerlink" title="线程通信（待补充）"></a>线程通信（待补充）</h1><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。</p>
<p>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。<br>该情况如下：</p>
<blockquote>
<p>Thread 1  locks A, waits for B<br>Thread 2  locks B, waits for A</p>
</blockquote>
<p>这里有一个TreeNode类的例子，它调用了不同实例的synchronized方法：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></div><div class="line">    TreeNode parent   = null;  </div><div class="line">    List children = new ArrayList();</div><div class="line"></div><div class="line">    public synchronized void addChild(TreeNode child)&#123;</div><div class="line">        <span class="keyword">if</span>(!this.children.contains(child)) &#123;</div><div class="line">            this.children.add(child);</div><div class="line">            child.setParentOnly(this);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public synchronized void addChildOnly(TreeNode child)&#123;</div><div class="line">        <span class="keyword">if</span>(!this.children.contains(child)&#123;</div><div class="line">            this.children.add(child);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public synchronized void setParent(TreeNode parent)&#123;</div><div class="line">        this.parent = parent;</div><div class="line">        parent.addChildOnly(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void setParentOnly(TreeNode parent)&#123;</div><div class="line">        this.parent = parent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果线程1调用parent.addChild(child)方法的同时有另外一个线程2调用child.setParent(parent)方法，两个线程中的parent表示的是同一个对象，child亦然，此时就会发生死锁。下面的伪代码说明了这个过程：</p>
<blockquote>
<p>Thread 1: parent.addChild(child); //locks parent<br>         –&gt; child.setParentOnly(parent);<br>Thread 2: child.setParent(parent); //locks child<br>         –&gt; parent.addChildOnly()</p>
</blockquote>
<p>先线程1调用parent.addChild(child)。因为addChild()是同步的，所以线程1会对parent对象加锁以不让其它线程访问该对象。</p>
<p>然后线程2调用child.setParent(parent)。因为setParent()是同步的，所以线程2会对child对象加锁以不让其它线程访问该对象。</p>
<p>现在child和parent对象被两个不同的线程锁住了。接下来线程1尝试调用child.setParentOnly()方法，但是由于child对象现在被线程2锁住的，所以该调用会被阻塞。线程2也尝试调用parent.addChildOnly()，但是由于parent对象现在被线程1锁住，导致线程2也阻塞在该方法处。现在两个线程都被阻塞并等待着获取另外一个线程所持有的锁。</p>
<p>注意：像上文描述的，这两个线程需要同时调用parent.addChild(child)和child.setParent(parent)方法，并且是同一个parent对象和同一个child对象，才有可能发生死锁。上面的代码可能运行一段时间才会出现死锁。</p>
<p>这些线程需要同时获得锁。举个例子，如果线程1稍微领先线程2，然后成功地锁住了A和B两个对象，那么线程2就会在尝试对B加锁的时候被阻塞，这样死锁就不会发生。因为线程调度通常是不可预测的，因此没有一个办法可以准确预测什么时候死锁会发生，仅仅是可能会发生。</p>
<h2 id="更复杂的死锁"><a href="#更复杂的死锁" class="headerlink" title="更复杂的死锁"></a>更复杂的死锁</h2><p>死锁可能不止包含2个线程，这让检测死锁变得更加困难。</p>
<h2 id="数据库的死锁"><a href="#数据库的死锁" class="headerlink" title="数据库的死锁"></a>数据库的死锁</h2><p>更加复杂的死锁场景发生在数据库事务中。一个数据库事务可能由多条SQL更新请求组成。当在一个事务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。同一个事务中每一个更新请求都可能会锁住一些记录。<br>当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁。<br>因为锁发生在不同的请求中，并且对于一个事务来说不可能提前知道所有它需要的锁，因此很难检测和避免数据库事务中的死锁。</p>
<h1 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h1><p>在有些情况下死锁是可以避免的。本文将展示三种用于避免死锁的技术：</p>
<ol>
<li>加锁顺序</li>
<li>加锁时限</li>
<li>死锁检测</li>
</ol>
<h2 id="加锁顺序"><a href="#加锁顺序" class="headerlink" title="加锁顺序"></a>加锁顺序</h2><p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。<br>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。看下面这个例子：</p>
<blockquote>
<p>Thread 1:<br>  lock A<br>  lock B<br>Thread 2:<br>   wait for A<br>   lock C (when A locked)<br>Thread 3:<br>   wait for A<br>   wait for B<br>   wait for C<br>如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。</p>
</blockquote>
<p>例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(译者注：获取锁A是获取锁C的必要条件)。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。</p>
<p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。</p>
<h2 id="锁时限"><a href="#锁时限" class="headerlink" title="锁时限"></a>锁时限</h2><p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。</p>
<p>以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场景：</p>
<blockquote>
<p>Thread 1 locks A<br>Thread 2 locks B</p>
<p>Thread 1 attempts to lock B but is blocked<br>Thread 2 attempts to lock A but is blocked</p>
<p>Thread 1’s lock attempt on B times out<br>Thread 1 backs up and releases A as well<br>Thread 1 waits randomly (e.g. 257 millis) before retrying.</p>
<p>Thread 2’s lock attempt on A times out<br>Thread 2 backs up and releases B as well<br>Thread 2 waits randomly (e.g. 43 millis) before retrying.</p>
</blockquote>
<p>在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时，线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁（除非线程2或者其它线程在线程1成功获得两个锁之前又获得其中的一些锁）。</p>
<p>需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。</p>
<p>此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相等的重试时间的概率就高的多（或者非常接近以至于会出现问题）。</p>
<p>(译者注：超时和重试机制是为了避免在同一时间出现的竞争，但是当线程很多时，其中两个或多个线程的超时时间一样或者接近的可能性就会很大，因此就算出现竞争而导致超时后，由于超时时间一样，它们又会同时开始重试，导致新一轮的竞争，带来了新的问题。)</p>
<p>这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。写一个自定义锁类不复杂，但超出了本文的内容。后续的Java并发系列会涵盖自定义锁的内容。</p>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p>
<p>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。</p>
<p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。</p>
<p>当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。</p>
<p>那么当检测出死锁时，这些线程该做些什么呢？</p>
<p>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。</p>
<p>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</p>
<h1 id="饥饿和公平"><a href="#饥饿和公平" class="headerlink" title="饥饿和公平"></a>饥饿和公平</h1><p>如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。解决饥饿的方案被称之为“公平性” – 即所有线程均能公平地获得运行机会。</p>
<h2 id="下面是本文讨论的主题："><a href="#下面是本文讨论的主题：" class="headerlink" title="下面是本文讨论的主题："></a>下面是本文讨论的主题：</h2><ol>
<li><p>Java中导致饥饿的原因：</p>
<ul>
<li>高优先级线程吞噬所有的低优先级线程的CPU时间。</li>
<li>线程被永久堵塞在一个等待进入同步块的状态。</li>
<li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)。</li>
</ul>
</li>
<li><p>在Java中实现公平性方案，需要:</p>
<ul>
<li>使用锁，而不是同步块。</li>
<li>公平锁。</li>
<li>注意性能方面。</li>
</ul>
</li>
</ol>
<h2 id="Java中导致饥饿的原因"><a href="#Java中导致饥饿的原因" class="headerlink" title="Java中导致饥饿的原因"></a>Java中导致饥饿的原因</h2><p>在Java中，下面三个常见的原因会导致线程饥饿：</p>
<ul>
<li>高优先级线程吞噬所有的低优先级线程的CPU时间。</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
<li>线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒。</li>
</ul>
<h3 id="高优先级线程吞噬所有的低优先级线程的CPU时间"><a href="#高优先级线程吞噬所有的低优先级线程的CPU时间" class="headerlink" title="高优先级线程吞噬所有的低优先级线程的CPU时间"></a>高优先级线程吞噬所有的低优先级线程的CPU时间</h3><p>你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你最好是不要改变其优先级值。</p>
<h3 id="线程被永久堵塞在一个等待进入同步块的状态"><a href="#线程被永久堵塞在一个等待进入同步块的状态" class="headerlink" title="线程被永久堵塞在一个等待进入同步块的状态"></a>线程被永久堵塞在一个等待进入同步块的状态</h3><p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</p>
<h2 id="在Java中实现公平性"><a href="#在Java中实现公平性" class="headerlink" title="在Java中实现公平性"></a>在Java中实现公平性</h2><p>虽Java不可能实现100%的公平性，我们依然可以通过同步结构在线程间实现公平性的提高。<br>首先来学习一段简单的同步态代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronizer</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSynchronized</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//do a lot of work which takes a long time</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有一个以上的线程调用doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。</p>
<h3 id="使用锁方式替代同步块"><a href="#使用锁方式替代同步块" class="headerlink" title="使用锁方式替代同步块"></a>使用锁方式替代同步块</h3><p>为了提高等待线程的公平性，我们使用锁方式来替代同步块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronizer</span></span>&#123;</div><div class="line">    Lock lock = <span class="keyword">new</span> Lock();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSynchronized</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">        <span class="keyword">this</span>.lock.lock();</div><div class="line">        <span class="comment">//critical section, do a lot of work which takes a long time</span></div><div class="line">        <span class="keyword">this</span>.lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。<br>下面是用Lock类做的一个实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked      = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Thread lockingThread = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(isLocked)&#123;</div><div class="line"></div><div class="line">        wait();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    isLocked = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    lockingThread = Thread.currentThread();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.lockingThread != Thread.currentThread())&#123;</div><div class="line"></div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(</div><div class="line"></div><div class="line">              <span class="string">"Calling thread has not locked this lock"</span>);</div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line">    isLocked = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    lockingThread = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    notify();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到上面对Lock的实现，如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果锁已经锁上（校对注：这里指的是isLocked等于true时），这些线程将阻塞在while(isLocked)循环的wait()调用里面。要记住的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。</p>
<p>这回看下doSynchronized()，你会注意到在lock()和unlock()之间的注释：在这两个调用之间的代码将运行很长一段时间。进一步设想，这段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。</p>
<p>在早些时候提到过，同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，wait()也不会做保障一定能唤醒线程（至于为什么，请看线程通信）。因此这个版本的Lock类和doSynchronized()那个版本就保障公平性而言，没有任何区别。</p>
<p>但我们能改变这种情况。当前的Lock类版本调用自己的wait()方法，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>下面来讲述将上面Lock类转变为公平锁FairLock。你会注意到新的实现和之前的Lock类中的同步和wait()/notify()稍有不同。</p>
<p>准确地说如何从之前的Lock类做到公平锁的设计是一个渐进设计的过程，每一步都是在解决上一步的问题而前进的：Nested Monitor Lockout, Slipped Conditions和Missed Signals。这些本身的讨论虽已超出本文的范围，但其中每一步的内容都将会专题进行讨论。重要的是，每一个调用lock()的线程都会进入一个队列，当解锁后，只有队列里的第一个线程被允许锁住Farlock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>           isLocked       = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> Thread            lockingThread  = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> List&lt;QueueObject&gt; waitingThreads =</div><div class="line">            <span class="keyword">new</span> ArrayList&lt;QueueObject&gt;();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    QueueObject queueObject           = <span class="keyword">new</span> QueueObject();</div><div class="line">    <span class="keyword">boolean</span>     isLockedForThisThread = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">        waitingThreads.add(queueObject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(isLockedForThisThread)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">        isLockedForThisThread =</div><div class="line">            isLocked || waitingThreads.get(<span class="number">0</span>) != queueObject;</div><div class="line">        <span class="keyword">if</span>(!isLockedForThisThread)&#123;</div><div class="line">          isLocked = <span class="keyword">true</span>;</div><div class="line">           waitingThreads.remove(queueObject);</div><div class="line">           lockingThread = Thread.currentThread();</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">try</span>&#123;</div><div class="line">        queueObject.doWait();</div><div class="line">      &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; waitingThreads.remove(queueObject); &#125;</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.lockingThread != Thread.currentThread())&#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(</div><div class="line">        <span class="string">"Calling thread has not locked this lock"</span>);</div><div class="line">    &#125;</div><div class="line">    isLocked      = <span class="keyword">false</span>;</div><div class="line">    lockingThread = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span>(waitingThreads.size() &gt; <span class="number">0</span>)&#123;</div><div class="line">      waitingThreads.get(<span class="number">0</span>).doNotify();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isNotified = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(!isNotified)&#123;</div><div class="line">        <span class="keyword">this</span>.wait();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.isNotified = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.isNotified = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">this</span>.notify();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>中进行嵌套。</p>
<p>FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程进行入队列。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。</p>
<p>请注意，在同一个同步块中，锁状态依然被检查和设置，以避免出现滑漏条件。</p>
<p>还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。</p>
<p>最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。</p>
<h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><p>如果比较Lock和FairLock类，你会注意到在FairLock类中lock()和unlock()还有更多需要深入的地方。这些额外的代码会导致FairLock的同步机制实现比Lock要稍微慢些。究竟存在多少影响，还依赖于应用在FairLock临界区执行的时长。执行时长越大，FairLock带来的负担影响就越小，当然这也和代码执行的频繁度相关。</p>
<h1 id="嵌套管程锁死"><a href="#嵌套管程锁死" class="headerlink" title="嵌套管程锁死"></a>嵌套管程锁死</h1><p>嵌套管程锁死类似于死锁， 下面是一个嵌套管程锁死的场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">线程1获得A对象的锁。</div><div class="line">线程1获得对象B的锁（同时持有对象A的锁）。</div><div class="line">线程1决定等待另一个线程的信号再继续。</div><div class="line">线程1调用B.wait()，从而释放了B对象上的锁，但仍然持有对象A的锁。</div><div class="line"></div><div class="line">线程2需要同时持有对象A和对象B的锁，才能向线程1发信号。</div><div class="line">线程2无法获得对象A上的锁，因为对象A上的锁当前正被线程1持有。</div><div class="line">线程2一直被阻塞，等待线程1释放对象A上的锁。</div><div class="line"></div><div class="line">线程1一直阻塞，等待线程2的信号，因此，不会释放对象A上的锁，</div><div class="line">    而线程2需要对象A上的锁才能给线程1发信号……</div></pre></td></tr></table></figure>
<p>你可以能会说，这是个空想的场景，好吧，让我们来看看下面这个比较挫的Lock实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//lock implementation with nested monitor lockout problem</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</div><div class="line">    <span class="keyword">protected</span> MonitorObject monitorObject = <span class="keyword">new</span> MonitorObject();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(isLocked)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>.monitorObject)&#123;</div><div class="line">                    <span class="keyword">this</span>.monitorObject.wait();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            isLocked = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">            <span class="keyword">this</span>.isLocked = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.monitorObject)&#123;</div><div class="line">                <span class="keyword">this</span>.monitorObject.notify();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，lock()方法首先在”this”上同步，然后在monitorObject上同步。如果isLocked等于false，因为线程不会继续调用monitorObject.wait()，那么一切都没有问题 。但是如果isLocked等于true，调用lock()方法的线程会在monitorObject.wait()上阻塞。</p>
<p>这里的问题在于，调用monitorObject.wait()方法只释放了monitorObject上的管程对象，而与”this“关联的管程对象并没有释放。换句话说，这个刚被阻塞的线程仍然持有”this”上的锁。</p>
<p>（校对注：如果一个线程持有这种Lock的时候另一个线程执行了lock操作）当一个已经持有这种Lock的线程想调用unlock(),就会在unlock()方法进入synchronized(this)块时阻塞。这会一直阻塞到在lock()方法中等待的线程离开synchronized(this)块。但是，在unlock中isLocked变为false，monitorObject.notify()被执行之后，lock()中等待的线程才会离开synchronized(this)块。</p>
<p>简而言之，在lock方法中等待的线程需要其它线程成功调用unlock方法来退出lock方法，但是，在lock()方法离开外层同步块之前，没有线程能成功执行unlock()。</p>
<p>结果就是，任何调用lock方法或unlock方法的线程都会一直阻塞。这就是嵌套管程锁死。</p>
<h2 id="一个更现实的例子"><a href="#一个更现实的例子" class="headerlink" title="一个更现实的例子"></a>一个更现实的例子</h2><p>你可能会说，这么挫的实现方式我怎么可能会做呢？你或许不会在里层的管程对象上调用wait或notify方法，但完全有可能会在外层的this上调。<br>有很多类似上面例子的情况。例如，如果你准备实现一个公平锁。你可能希望每个线程在它们各自的QueueObject上调用wait()，这样就可以每次唤醒一个线程。</p>
<p>下面是一个比较挫的公平锁实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Fair Lock implementation with nested monitor lockout problem</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> Thread lockingThread = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> List waitingThreads =</div><div class="line">        <span class="keyword">new</span> ArrayList();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">        QueueObject queueObject = <span class="keyword">new</span> QueueObject();</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">            waitingThreads.add(queueObject);</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(isLocked ||</div><div class="line">                waitingThreads.get(<span class="number">0</span>) != queueObject)&#123;</div><div class="line"></div><div class="line">                <span class="keyword">synchronized</span>(queueObject)&#123;</div><div class="line">                    <span class="keyword">try</span>&#123;</div><div class="line">                        queueObject.wait();</div><div class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                        waitingThreads.remove(queueObject);</div><div class="line">                        <span class="keyword">throw</span> e;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            waitingThreads.remove(queueObject);</div><div class="line">            isLocked = <span class="keyword">true</span>;</div><div class="line">            lockingThread = Thread.currentThread();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.lockingThread != Thread.currentThread())&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(</div><div class="line">                <span class="string">"Calling thread has not locked this lock"</span>);</div><div class="line">        &#125;</div><div class="line">        isLocked = <span class="keyword">false</span>;</div><div class="line">        lockingThread = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(waitingThreads.size() &gt; <span class="number">0</span>)&#123;</div><div class="line">            QueueObject queueObject = waitingThread.get(<span class="number">0</span>);</div><div class="line">            <span class="keyword">synchronized</span>(queueObject)&#123;</div><div class="line">                queueObject.notify();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>乍看之下，嗯，很好，但是请注意lock方法是怎么调用queueObject.wait()的，在方法内部有两个synchronized块，一个锁定this，一个嵌在上一个synchronized块内部，它锁定的是局部变量queueObject。<br>当一个线程调用queueObject.wait()方法的时候，它仅仅释放的是在queueObject对象实例的锁，并没有释放”this”上面的锁。</p>
<p>现在我们还有一个地方需要特别注意， unlock方法被声明成了synchronized，这就相当于一个synchronized（this）块。这就意味着，如果一个线程在lock()中等待，该线程将持有与this关联的管程对象。所有调用unlock()的线程将会一直保持阻塞，等待着前面那个已经获得this锁的线程释放this锁，但这永远也发生不了，因为只有某个线程成功地给lock()中等待的线程发送了信号，this上的锁才会释放，但只有执行unlock()方法才会发送这个信号。</p>
<p>因此，上面的公平锁的实现会导致嵌套管程锁死。更好的公平锁实现方式可以参考Starvation and Fairness。</p>
<h2 id="嵌套管程锁死-VS-死锁"><a href="#嵌套管程锁死-VS-死锁" class="headerlink" title="嵌套管程锁死 VS 死锁"></a>嵌套管程锁死 VS 死锁</h2><p>嵌套管程锁死与死锁很像：都是线程最后被一直阻塞着互相等待。</p>
<p>但是两者又不完全相同。在死锁中我们已经对死锁有了个大概的解释，死锁通常是因为两个线程获取锁的顺序不一致造成的，线程1锁住A，等待获取B，线程2已经获取了B，再等待获取A。如死锁避免中所说的，死锁可以通过总是以相同的顺序获取锁来避免。<br>但是发生嵌套管程锁死时锁获取的顺序是一致的。线程1获得A和B，然后释放B，等待线程2的信号。线程2需要同时获得A和B，才能向线程1发送信号。所以，一个线程在等待唤醒，另一个线程在等待想要的锁被释放。</p>
<p>不同点归纳如下：</p>
<blockquote>
<p>死锁中，二个线程都在等待对方释放锁。</p>
<p>嵌套管程锁死中，线程1持有锁A，同时等待从线程2发来的信号，线程2需要锁A来发信号给线程1。</p>
</blockquote>
<h1 id="Slipped-Conditions-未完"><a href="#Slipped-Conditions-未完" class="headerlink" title="Slipped Conditions(未完)"></a>Slipped Conditions(未完)</h1><p>所谓Slipped conditions，就是说， 从一个线程检查某一特定条件到该线程操作此条件期间，这个条件已经被其它线程改变，导致第一个线程在该条件上执行了错误的操作。这里有一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">        <span class="keyword">while</span>(isLocked)&#123;</div><div class="line">          <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">this</span>.wait();</div><div class="line">          &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">            <span class="comment">//do nothing, keep waiting</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">        isLocked = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</div><div class="line">      isLocked = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">this</span>.notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，lock()方法包含了两个同步块。第一个同步块执行wait操作直到isLocked变为false才退出，第二个同步块将isLocked置为true，以此来锁住这个Lock实例避免其它线程通过lock()方法。</p>
<p>我们可以设想一下，假如在某个时刻isLocked为false， 这个时候，有两个线程同时访问lock方法。如果第一个线程先进入第一个同步块，这个时候它会发现isLocked为false，若此时允许第二个线程执行，它也进入第一个同步块，同样发现isLocked是false。现在两个线程都检查了这个条件为false，然后它们都会继续进入第二个同步块中并设置isLocked为true。</p>
<p>这个场景就是slipped conditions的例子，两个线程检查同一个条件， 然后退出同步块，因此在这两个线程改变条件之前，就允许其它线程来检查这个条件。换句话说，条件被某个线程检查到该条件被此线程改变期间，这个条件已经被其它线程改变过了。</p>
<p>为避免slipped conditions，条件的检查与设置必须是原子的，也就是说，在第一个线程检查和设置条件期间，不会有其它线程检查这个条件。</p>
<p>解决上面问题的方法很简单，只是简单的把isLocked = true这行代码移到第一个同步块中，放在while循环后面即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">        <span class="keyword">while</span>(isLocked)&#123;</div><div class="line">          <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">this</span>.wait();</div><div class="line">          &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">            <span class="comment">//do nothing, keep waiting</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        isLocked = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</div><div class="line">      isLocked = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">this</span>.notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="java中的锁"><a href="#java中的锁" class="headerlink" title="java中的锁"></a>java中的锁</h1><p>锁像synchronized同步块一样，是一种线程同步机制，但比Java中的synchronized同步块更复杂。因为锁（以及其它更高级的线程同步机制）是由synchronized同步块的方式实现的，所以我们还不能完全摆脱synchronized关键字（译者注：这说的是Java 5之前的情况）。</p>
<p>自Java 5开始，java.util.concurrent.locks包中包含了一些锁的实现，因此你不用去实现自己的锁了。但是你仍然需要去了解怎样使用这些锁，且了解这些实现背后的理论也是很有用处的。可以参考我对java.util.concurrent.locks.Lock的介绍，以了解更多关于锁的信息。</p>
<p>以下是本文所涵盖的主题：</p>
<ul>
<li>一个简单的锁</li>
<li>锁的可重入性</li>
<li>锁的公平性</li>
<li>在finally语句中调用unlock()</li>
</ul>
<h2 id="一个简单的锁"><a href="#一个简单的锁" class="headerlink" title="一个简单的锁"></a>一个简单的锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">            <span class="keyword">return</span> ++count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在inc()方法中有一个synchronized(this)代码块。该代码块可以保证在同一时间只有一个线程可以执行return ++count。虽然在synchronized的同步块中的代码可以更加复杂，但是++count这种简单的操作已经足以表达出线程同步的意思。</p>
<p>以下的Counter类用Lock代替synchronized达到了同样的目的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> Lock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">int</span> newCount = ++count;</div><div class="line">        lock.unlock();</div><div class="line">        <span class="keyword">return</span> newCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>lock()方法会对Lock实例对象进行加锁，因此所有对该对象调用lock()方法的线程都会被阻塞，直到该Lock对象的unlock()方法被调用。</p>
<p>这里有一个Lock类的简单实现：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Counter</span>&#123;</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></div><div class="line">    private boolean isLocked = <span class="literal">false</span>;</div><div class="line">    public synchronized void lock()</div><div class="line">        throws InterruptedException&#123;</div><div class="line">        <span class="keyword">while</span>(isLocked)&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        isLocked = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    public synchronized void unlock()&#123;</div><div class="line">        isLocked = <span class="literal">false</span>;</div><div class="line">        notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意其中的while(isLocked)循环，它又被叫做“自旋锁”。自旋锁以及wait()和notify()方法在线程通信这篇文章中有更加详细的介绍。当isLocked为true时，调用lock()的线程在wait()调用上阻塞等待。为防止该线程没有收到notify()调用也从wait()中返回（也称作虚假唤醒），这个线程会重新去检查isLocked条件以决定当前是否可以安全地继续执行还是需要重新保持等待，而不是认为线程被唤醒了就可以安全地继续执行了。如果isLocked为false，当前线程会退出while(isLocked)循环，并将isLocked设回true，让其它正在调用lock()方法的线程能够在Lock实例上加锁。</p>
<p>当线程完成了临界区（位于lock()和unlock()之间）中的代码，就会调用unlock()。执行unlock()会重新将isLocked设置为false，并且通知（唤醒）其中一个（若有的话）在lock()方法中调用了wait()函数而处于等待状态的线程。</p>
<h2 id="锁的可重入性"><a href="#锁的可重入性" class="headerlink" title="锁的可重入性"></a>锁的可重入性</h2><p>Java中的synchronized同步块是可重入的。这意味着如果一个java线程进入了代码中的synchronized同步块，并因此获得了该同步块使用的同步对象对应的管程上的锁，那么这个线程可以进入由同一个管程对象所同步的另一个java代码块。下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reentrant</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">outer</span><span class="params">()</span></span>&#123;</div><div class="line">        inner();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//do something</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意outer()和inner()都被声明为synchronized，这在Java中和synchronized(this)块等效。如果一个线程调用了outer()，在outer()里调用inner()就没有什么问题，因为这两个方法（代码块）都由同一个管程对象（”this”)所同步。如果一个线程已经拥有了一个管程对象上的锁，那么它就有权访问被这个管程对象同步的所有代码块。这就是可重入。线程可以进入任何一个它已经拥有的锁所同步着的代码块。</p>
<p>前面给出的锁实现不是可重入的。如果我们像下面这样重写Reentrant类，当线程调用outer()时，会在inner()方法的lock.lock()处阻塞住。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reentrant2</span></span>&#123;</div><div class="line">    Lock lock = <span class="keyword">new</span> Lock();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">outer</span><span class="params">()</span></span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        inner();</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="comment">//do something</span></div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用outer()的线程首先会锁住Lock实例，然后继续调用inner()。inner()方法中该线程将再一次尝试锁住Lock实例，结果该动作会失败（也就是说该线程会被阻塞），因为这个Lock实例已经在outer()方法中被锁住了。</p>
<p>两次lock()之间没有调用unlock()，第二次调用lock就会阻塞，看过lock()实现后，会发现原因很明显：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</div><div class="line">    <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">        <span class="keyword">while</span>(isLocked)&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        isLocked = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个线程是否被允许退出lock()方法是由while循环（自旋锁）中的条件决定的。当前的判断条件是只有当isLocked为false时lock操作才被允许，而没有考虑是哪个线程锁住了它。</p>
<p>为了让这个Lock类具有可重入性，我们需要对它做一点小的改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</div><div class="line">    <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</div><div class="line">    Thread  lockedBy = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> lockedCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">        Thread callingThread =</div><div class="line">            Thread.currentThread();</div><div class="line">        <span class="keyword">while</span>(isLocked &amp;&amp; lockedBy != callingThread)&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        isLocked = <span class="keyword">true</span>;</div><div class="line">        lockedCount++;</div><div class="line">        lockedBy = callingThread;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(Thread.curentThread() ==</div><div class="line">            <span class="keyword">this</span>.lockedBy)&#123;</div><div class="line">            lockedCount--;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(lockedCount == <span class="number">0</span>)&#123;</div><div class="line">                isLocked = <span class="keyword">false</span>;</div><div class="line">                notify();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到现在的while循环（自旋锁）也考虑到了已锁住该Lock实例的线程。如果当前的锁对象没有被加锁(isLocked = false)，或者当前调用线程已经对该Lock实例加了锁，那么while循环就不会被执行，调用lock()的线程就可以退出该方法（译者注：“被允许退出该方法”在当前语义下就是指不会调用wait()而导致阻塞）。</p>
<p>除此之外，我们需要记录同一个线程重复对一个锁对象加锁的次数。否则，一次unblock()调用就会解除整个锁，即使当前锁已经被加锁过多次。在unlock()调用没有达到对应lock()调用的次数之前，我们不希望锁被解除。</p>
<p>现在这个Lock类就是可重入的了。</p>
<h2 id="锁的公平性"><a href="#锁的公平性" class="headerlink" title="锁的公平性"></a>锁的公平性</h2><p>Java的synchronized块并不保证尝试进入它们的线程的顺序。因此，如果多个线程不断竞争访问相同的synchronized同步块，就存在一种风险，其中一个或多个线程永远也得不到访问权 —— 也就是说访问权总是分配给了其它线程。这种情况被称作线程饥饿。为了避免这种问题，锁需要实现公平性。本文所展现的锁在内部是用synchronized同步块实现的，因此它们也不保证公平性。饥饿和公平中有更多关于该内容的讨论。</p>
<h2 id="在finally语句中调用unlock"><a href="#在finally语句中调用unlock" class="headerlink" title="在finally语句中调用unlock()"></a>在finally语句中调用unlock()</h2><p>如果用Lock来保护临界区，并且临界区有可能会抛出异常，那么在finally语句中调用unlock()就显得非常重要了。这样可以保证这个锁对象可以被解锁以便其它线程能继续对其加锁。以下是一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//do critical section code,</span></div><div class="line">    <span class="comment">//which may throw exception</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个简单的结构可以保证当临界区抛出异常时Lock对象可以被解锁。如果不是在finally语句中调用的unlock()，当临界区抛出异常时，Lock对象将永远停留在被锁住的状态，这会导致其它所有在该Lock对象上调用lock()的线程一直阻塞。</p>
<h1 id="Java中的读-写锁"><a href="#Java中的读-写锁" class="headerlink" title="Java中的读/写锁"></a>Java中的读/写锁</h1><p>相比Java中的锁(Locks in Java)里Lock实现，读写锁更复杂一些。假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候，两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写（译者注：也就是说：读-读能共存，读-写不能共存，写-写不能共存）。这就需要一个读/写锁来解决这个问题。</p>
<p>Java5在java.util.concurrent包中已经包含了读写锁。尽管如此，我们还是应该了解其实现背后的原理。</p>
<p>以下是本文的主题</p>
<ol>
<li>读/写锁的Java实现(Read / Write Lock Java Implementation)</li>
<li>读/写锁的重入(Read / Write Lock Reentrance)</li>
<li>读锁重入(Read Reentrance)</li>
<li>写锁重入(Write Reentrance)</li>
<li>读锁升级到写锁(Read to Write Reentrance)</li>
<li>写锁降级到读锁(Write to Read Reentrance)</li>
<li>可重入的ReadWriteLock的完整实现(Fully Reentrant ReadWriteLock)<br>在finally中调用unlock() (Calling unlock() from a finally-clause)</li>
</ol>
<h2 id="读-写锁的Java实现"><a href="#读-写锁的Java实现" class="headerlink" title="读/写锁的Java实现"></a>读/写锁的Java实现</h2><p>先让我们对读写访问资源的条件做个概述：</p>
<p>读取 没有线程正在做写操作，且没有线程在请求写操作。</p>
<p>写入 没有线程正在做读写操作。</p>
<p>如果某个线程想要读取资源，只要没有线程正在对该资源进行写操作且没有线程请求对该资源的写操作即可。我们假设对写操作的请求比对读操作的请求更重要，就要提升写请求的优先级。此外，如果读操作发生的比较频繁，我们又没有提升写操作的优先级，那么就会产生“饥饿”现象。请求写操作的线程会一直阻塞，直到所有的读线程都从ReadWriteLock上解锁了。如果一直保证新线程的读操作权限，那么等待写操作的线程就会一直阻塞下去，结果就是发生“饥饿”。因此，只有当没有线程正在锁住ReadWriteLock进行写操作，且没有线程请求该锁准备执行写操作时，才能保证读操作继续。</p>
<p>当其它线程没有对共享资源进行读操作或者写操作时，某个线程就有可能获得该共享资源的写锁，进而对共享资源进行写操作。有多少线程请求了写锁以及以何种顺序请求写锁并不重要，除非你想保证写锁请求的公平性。</p>
<p>按照上面的叙述，简单的实现出一个读/写锁，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> readers = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writers = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeRequests = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> </span></div><div class="line">        <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">        <span class="keyword">while</span>(writers &gt; <span class="number">0</span> || writeRequests &gt; <span class="number">0</span>)&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        readers++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">()</span></span>&#123;</div><div class="line">        readers--;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> </span></div><div class="line">        <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">        writeRequests++;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(readers &gt; <span class="number">0</span> || writers &gt; <span class="number">0</span>)&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        writeRequests--;</div><div class="line">        writers++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">()</span> </span></div><div class="line">        <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">        writers--;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ReadWriteLock类中，读锁和写锁各有一个获取锁和释放锁的方法。</p>
<p>读锁的实现在lockRead()中,只要没有线程拥有写锁（writers==0），且没有线程在请求写锁（writeRequests ==0），所有想获得读锁的线程都能成功获取。</p>
<p>写锁的实现在lockWrite()中,当一个线程想获得写锁的时候，首先会把写锁请求数加1（writeRequests++），然后再去判断是否能够真能获得写锁，当没有线程持有读锁（readers==0 ）,且没有线程持有写锁（writers==0）时就能获得写锁。有多少线程在请求写锁并无关系。</p>
<p>需要注意的是，在两个释放锁的方法（unlockRead，unlockWrite）中，都调用了notifyAll方法，而不是notify。要解释这个原因，我们可以想象下面一种情形：</p>
<p>如果有线程在等待获取读锁，同时又有线程在等待获取写锁。如果这时其中一个等待读锁的线程被notify方法唤醒，但因为此时仍有请求写锁的线程存在（writeRequests&gt;0），所以被唤醒的线程会再次进入阻塞状态。然而，等待写锁的线程一个也没被唤醒，就像什么也没发生过一样（译者注：信号丢失现象）。如果用的是notifyAll方法，所有的线程都会被唤醒，然后判断能否获得其请求的锁。</p>
<p>用notifyAll还有一个好处。如果有多个读线程在等待读锁且没有线程在等待写锁时，调用unlockWrite()后，所有等待读锁的线程都能立马成功获取读锁 —— 而不是一次只允许一个。</p>
<h2 id="读-写锁的重入"><a href="#读-写锁的重入" class="headerlink" title="读/写锁的重入"></a>读/写锁的重入</h2><p>上面实现的读/写锁(ReadWriteLock) 是不可重入的，当一个已经持有写锁的线程再次请求写锁时，就会被阻塞。原因是已经有一个写线程了——就是它自己。此外，考虑下面的例子：</p>
<p>Thread 1 获得了读锁<br>Thread 2 请求写锁，但因为Thread 1 持有了读锁，所以写锁请求被阻塞。<br>Thread 1 再想请求一次读锁，但因为Thread 2处于请求写锁的状态，所以想再次获取读锁也会被阻塞。<br>上面这种情形使用前面的ReadWriteLock就会被锁定——一种类似于死锁的情形。不会再有线程能够成功获取读锁或写锁了。</p>
<p>为了让ReadWriteLock可重入，需要对它做一些改进。下面会分别处理读锁的重入和写锁的重入。</p>
<h2 id="读锁重入"><a href="#读锁重入" class="headerlink" title="读锁重入"></a>读锁重入</h2><p>为了让ReadWriteLock的读锁可重入，我们要先为读锁重入建立规则：</p>
<p>要保证某个线程中的读锁可重入，要么满足获取读锁的条件（没有写或写请求），要么已经持有读锁（不管是否有写请求）。<br>要确定一个线程是否已经持有读锁，可以用一个map来存储已经持有读锁的线程以及对应线程获取读锁的次数，当需要判断某个线程能否获得读锁时，就利用map中存储的数据进行判断。下面是方法lockRead和unlockRead修改后的的代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span>&#123;</span></div><div class="line">    private Map&lt;Thread, Integer&gt; readingThreads =</div><div class="line">        new HashMap&lt;Thread, Integer&gt;();</div><div class="line"></div><div class="line">    private int writers = <span class="number">0</span>;</div><div class="line">    private int writeRequests = <span class="number">0</span>;</div><div class="line"></div><div class="line">    public synchronized void lockRead() </div><div class="line">        throws InterruptedException&#123;</div><div class="line">        Thread callingThread = Thread.currentThread();</div><div class="line">        <span class="keyword">while</span>(! canGrantReadAccess(callingThread))&#123;</div><div class="line">            wait();                                                                   </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        readingThreads.put(callingThread,</div><div class="line">            (getAccessCount(callingThread) + <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void unlockRead()&#123;</div><div class="line">        Thread callingThread = Thread.currentThread();</div><div class="line">        int accessCount = getAccessCount(callingThread);</div><div class="line">        <span class="keyword">if</span>(accessCount == <span class="number">1</span>) &#123; </div><div class="line">            readingThreads.remove(callingThread); </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            readingThreads.put(callingThread, (accessCount -<span class="number">1</span>)); </div><div class="line">        &#125;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean canGrantReadAccess(Thread callingThread)&#123;</div><div class="line">        <span class="keyword">if</span>(writers &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(isReader(callingThread) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(writeRequests &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getReadAccessCount(Thread callingThread)&#123;</div><div class="line">        Integer accessCount = readingThreads.get(callingThread);</div><div class="line">        <span class="keyword">if</span>(accessCount == null) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> accessCount.intValue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean isReader(Thread callingThread)&#123;</div><div class="line">        <span class="keyword">return</span> readingThreads.get(callingThread) != null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中我们可以看到，只有在没有线程拥有写锁的情况下才允许读锁的重入。此外，重入的读锁比写锁优先级高。</p>
<h2 id="写锁重入"><a href="#写锁重入" class="headerlink" title="写锁重入"></a>写锁重入</h2><p>仅当一个线程已经持有写锁，才允许写锁重入（再次获得写锁）。下面是方法lockWrite和unlockWrite修改后的的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Thread, Integer&gt; readingThreads =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;Thread, Integer&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeAccesses    = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeRequests    = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> Thread writingThread = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> </span></div><div class="line">        <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">        writeRequests++;</div><div class="line">        Thread callingThread = Thread.currentThread();</div><div class="line">        <span class="keyword">while</span>(!canGrantWriteAccess(callingThread))&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        writeRequests--;</div><div class="line">        writeAccesses++;</div><div class="line">        writingThread = callingThread;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">()</span> </span></div><div class="line">        <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">        writeAccesses--;</div><div class="line">        <span class="keyword">if</span>(writeAccesses == <span class="number">0</span>)&#123;</div><div class="line">            writingThread = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canGrantWriteAccess</span><span class="params">(Thread callingThread)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(hasReaders()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>(writingThread == <span class="keyword">null</span>)    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span>(!isWriter(callingThread)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasReaders</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> readingThreads.size() &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isWriter</span><span class="params">(Thread callingThread)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> writingThread == callingThread;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="读锁升级到写锁"><a href="#读锁升级到写锁" class="headerlink" title="读锁升级到写锁"></a>读锁升级到写锁</h2><p>有时，我们希望一个拥有读锁的线程，也能获得写锁。想要允许这样的操作，要求这个线程是唯一一个拥有读锁的线程。writeLock()需要做点改动来达到这个目的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Thread, Integer&gt; readingThreads =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;Thread, Integer&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeAccesses    = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeRequests    = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> Thread writingThread = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> </span></div><div class="line">        <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">        writeRequests++;</div><div class="line">        Thread callingThread = Thread.currentThread();</div><div class="line">        <span class="keyword">while</span>(!canGrantWriteAccess(callingThread))&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        writeRequests--;</div><div class="line">        writeAccesses++;</div><div class="line">        writingThread = callingThread;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">        writeAccesses--;</div><div class="line">        <span class="keyword">if</span>(writeAccesses == <span class="number">0</span>)&#123;</div><div class="line">            writingThread = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canGrantWriteAccess</span><span class="params">(Thread callingThread)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(isOnlyReader(callingThread)) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span>(hasReaders()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>(writingThread == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span>(!isWriter(callingThread)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasReaders</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> readingThreads.size() &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isWriter</span><span class="params">(Thread callingThread)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> writingThread == callingThread;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOnlyReader</span><span class="params">(Thread thread)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> readers == <span class="number">1</span> &amp;&amp; readingThreads.get(callingThread) != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="写锁降级到读锁"><a href="#写锁降级到读锁" class="headerlink" title="写锁降级到读锁"></a>写锁降级到读锁</h2><p>有时拥有写锁的线程也希望得到读锁。如果一个线程拥有了写锁，那么自然其它线程是不可能拥有读锁或写锁了。所以对于一个拥有写锁的线程，再获得读锁，是不会有什么危险的。我们仅仅需要对上面canGrantReadAccess方法进行简单地修改：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReadWriteLock</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">canGrantReadAccess</span>(<span class="params">Thread callingThread</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(isWriter(callingThread)) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(writingThread != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(isReader(callingThread) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(writeRequests &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="可重入的ReadWriteLock的完整实现"><a href="#可重入的ReadWriteLock的完整实现" class="headerlink" title="可重入的ReadWriteLock的完整实现"></a>可重入的ReadWriteLock的完整实现</h2><p>下面是完整的ReadWriteLock实现。为了便于代码的阅读与理解，简单对上面的代码做了重构。重构后的代码如下。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReadWriteLock</span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Thread, Integer&gt; readingThreads =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;Thread, Integer&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeAccesses    = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeRequests    = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> Thread writingThread = <span class="literal">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">lockRead</span>(<span class="params"></span>) </span></div><div class="line">        throws InterruptedException&#123;</div><div class="line">        Thread callingThread = Thread.currentThread();</div><div class="line">        <span class="keyword">while</span>(! canGrantReadAccess(callingThread))&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        readingThreads.put(callingThread,</div><div class="line">            (getReadAccessCount(callingThread) + <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">canGrantReadAccess</span>(<span class="params">Thread callingThread</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(isWriter(callingThread)) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(hasWriter()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(isReader(callingThread)) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(hasWriteRequests()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">unlockRead</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        Thread callingThread = Thread.currentThread();</div><div class="line">        <span class="keyword">if</span>(!isReader(callingThread))&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(</div><div class="line">                <span class="string">"Calling Thread does not"</span> +</div><div class="line">                <span class="string">" hold a read lock on this ReadWriteLock"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> accessCount = getReadAccessCount(callingThread);</div><div class="line">        <span class="keyword">if</span>(accessCount == <span class="number">1</span>)&#123; </div><div class="line">            readingThreads.remove(callingThread); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            readingThreads.put(callingThread, (accessCount <span class="number">-1</span>));</div><div class="line">        &#125;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">lockWrite</span>(<span class="params"></span>) </span></div><div class="line">        throws InterruptedException&#123;</div><div class="line">        writeRequests++;</div><div class="line">        Thread callingThread = Thread.currentThread();</div><div class="line">        <span class="keyword">while</span>(!canGrantWriteAccess(callingThread))&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        writeRequests--;</div><div class="line">        writeAccesses++;</div><div class="line">        writingThread = callingThread;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">unlockWrite</span>(<span class="params"></span>) </span></div><div class="line">        throws InterruptedException&#123;</div><div class="line">        <span class="keyword">if</span>(!isWriter(Thread.currentThread())&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(</div><div class="line">            <span class="string">"Calling Thread does not"</span> +</div><div class="line">            <span class="string">" hold the write lock on this ReadWriteLock"</span>);</div><div class="line">        &#125;</div><div class="line">        writeAccesses--;</div><div class="line">        <span class="keyword">if</span>(writeAccesses == <span class="number">0</span>)&#123;</div><div class="line">            writingThread = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">canGrantWriteAccess</span>(<span class="params">Thread callingThread</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(isOnlyReader(callingThread)) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(hasReaders()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(writingThread == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(!isWriter(callingThread)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getReadAccessCount</span>(<span class="params">Thread callingThread</span>)</span>&#123;</div><div class="line">        Integer accessCount = readingThreads.<span class="keyword">get</span>(callingThread);</div><div class="line">        <span class="keyword">if</span>(accessCount == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> accessCount.intValue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">hasReaders</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> readingThreads.size() &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">isReader</span>(<span class="params">Thread callingThread</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> readingThreads.<span class="keyword">get</span>(callingThread) != <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">isOnlyReader</span>(<span class="params">Thread callingThread</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> readingThreads.size() == <span class="number">1</span> &amp;&amp;</div><div class="line">            readingThreads.<span class="keyword">get</span>(callingThread) != <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">hasWriter</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> writingThread != <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">isWriter</span>(<span class="params">Thread callingThread</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> writingThread == callingThread;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">hasWriteRequests</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.writeRequests &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="在finally中调用unlock"><a href="#在finally中调用unlock" class="headerlink" title="在finally中调用unlock()"></a>在finally中调用unlock()</h2><p>在利用ReadWriteLock来保护临界区时，如果临界区可能抛出异常，在finally块中调用readUnlock()和writeUnlock()就显得很重要了。这样做是为了保证ReadWriteLock能被成功解锁，然后其它线程可以请求到该锁。这里有个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lock.lockWrite();</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//do critical section code, which may throw exception</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    lock.unlockWrite();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这样的代码结构能够保证临界区中抛出异常时ReadWriteLock也会被释放。如果unlockWrite方法不是在finally块中调用的，当临界区抛出了异常时，ReadWriteLock 会一直保持在写锁定状态，就会导致所有调用lockRead()或lockWrite()的线程一直阻塞。唯一能够重新解锁ReadWriteLock的因素可能就是ReadWriteLock是可重入的，当抛出异常时，这个线程后续还可以成功获取这把锁，然后执行临界区以及再次调用unlockWrite()，这就会再次释放ReadWriteLock。但是如果该线程后续不再获取这把锁了呢？所以，在finally中调用unlockWrite对写出健壮代码是很重要的。</p>
<h1 id="重入锁死"><a href="#重入锁死" class="headerlink" title="重入锁死"></a>重入锁死</h1><p>免重入锁死有两个选择：</p>
<ul>
<li>编写代码时避免再次获取已经持有的锁</li>
<li>使用可重入锁<br>至于哪个选择最适合你的项目，得视具体情况而定。可重入锁通常没有不可重入锁那么好的表现，而且实现起来复杂，但这些情况在你的项目中也许算不上什么问题。无论你的项目用锁来实现方便还是不用锁方便，可重入特性都需要根据具体问题具体分析。</li>
</ul>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>Semaphore（信号量） 是一个线程同步结构，用于在线程间传递信号，以避免出现信号丢失（译者注：下文会具体介绍），或者像锁一样用于保护一个关键区域。自从5.0开始，jdk在java.util.concurrent包里提供了Semaphore 的官方实现，因此大家不需要自己去实现Semaphore。但是还是很有必要去熟悉如何使用Semaphore及其背后的原理</p>
<p>本文的涉及的主题如下： </p>
<ol>
<li>简单的Semaphore实现</li>
<li>使用Semaphore来发出信号</li>
<li>可计数的Semaphore</li>
<li>有上限的Semaphore</li>
<li>把Semaphore当锁来使用</li>
</ol>
<h2 id="简单的Semaphore实现"><a href="#简单的Semaphore实现" class="headerlink" title="简单的Semaphore实现"></a>简单的Semaphore实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> signal = <span class="keyword">false</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.signal = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">this</span>.notify();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    <span class="keyword">while</span>(!<span class="keyword">this</span>.signal) wait();</div><div class="line">    <span class="keyword">this</span>.signal = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ke方法发出一个被存放在Semaphore内部的信号，而Release方法则等待一个信号，当其接收到信号后，标记位signal被清空，然后该方法终止。</p>
<p>使用这个semaphore可以避免错失某些信号通知。用take方法来代替notify，release方法来代替wait。如果某线程在调用release等待之前调用take方法，那么调用release方法的线程仍然知道take方法已经被某个线程调用过了，因为该Semaphore内部保存了take方法发出的信号。而wait和notify方法就没有这样的功能。</p>
<p>当用semaphore来产生信号时，take和release这两个方法名看起来有点奇怪。这两个名字来源于后面把semaphore当做锁的例子，后面会详细介绍这个例子，在该例子中，take和release这两个名字会变得很合理。</p>
<h2 id="使用Semaphore来产生信号"><a href="#使用Semaphore来产生信号" class="headerlink" title="使用Semaphore来产生信号"></a>使用Semaphore来产生信号</h2><p>下面的例子中，两个线程通过Semaphore发出的信号来通知对方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore();</div><div class="line">SendingThread sender = <span class="keyword">new</span> SendingThread(semaphore)；</div><div class="line">ReceivingThread receiver = <span class="keyword">new</span> ReceivingThread(semaphore);</div><div class="line"></div><div class="line">receiver.start();</div><div class="line">sender.start();</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendingThread</span> </span>&#123;</div><div class="line">    Semaphore semaphore = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SendingThread</span><span class="params">(Semaphore semaphore)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.semaphore = semaphore;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//do something, then signal</span></div><div class="line">            <span class="keyword">this</span>.semaphore.take();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecevingThread</span> </span>&#123;</div><div class="line">    Semaphore semaphore = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReceivingThread</span><span class="params">(Semaphore semaphore)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.semaphore = semaphore;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">this</span>.semaphore.release();</div><div class="line">            <span class="comment">//receive signal, then do something...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="可计数的Semaphore"><a href="#可计数的Semaphore" class="headerlink" title="可计数的Semaphore"></a>可计数的Semaphore</h2><p>上面提到的Semaphore的简单实现并没有计算通过调用take方法所产生信号的数量。可以把它改造成具有计数功能的Semaphore。下面是一个可计数的Semaphore的简单实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSemaphore</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.signals++;</div><div class="line">        <span class="keyword">this</span>.notify();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.signals == <span class="number">0</span>) wait();</div><div class="line">        <span class="keyword">this</span>.signals--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="有上限的Semaphore"><a href="#有上限的Semaphore" class="headerlink" title="有上限的Semaphore"></a>有上限的Semaphore</h2><p>上面的CountingSemaphore并没有限制信号的数量。下面的代码将CountingSemaphore改造成一个信号数量有上限的BoundedSemaphore。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bound   = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedSemaphore</span><span class="params">(<span class="keyword">int</span> upperBound)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.bound = upperBound;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.signals == bound) wait();</div><div class="line">        <span class="keyword">this</span>.signals++;</div><div class="line">        <span class="keyword">this</span>.notify();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.signals == <span class="number">0</span>) wait();</div><div class="line">        <span class="keyword">this</span>.signals--;</div><div class="line">        <span class="keyword">this</span>.notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在BoundedSemaphore中，当已经产生的信号数量达到了上限，take方法将阻塞新的信号产生请求，直到某个线程调用release方法后，被阻塞于take方法的线程才能传递自己的信号。</p>
<p>##　把Semaphore当锁来使用<br>当信号量的数量上限是1时，Semaphore可以被当做锁来使用。通过take和release方法来保护关键区域。请看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BoundedSemaphore semaphore = <span class="keyword">new</span> BoundedSemaphore(<span class="number">1</span>);</div><div class="line">...</div><div class="line">semaphore.take();</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//critical section</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    semaphore.release();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在前面的例子中，Semaphore被用来在多个线程之间传递信号，这种情况下，take和release分别被不同的线程调用。但是在锁这个例子中，take和release方法将被同一线程调用，因为只允许一个线程来获取信号（允许进入关键区域的信号），其它调用take方法获取信号的线程将被阻塞，知道第一个调用take方法的线程调用release方法来释放信号。对release方法的调用永远不会被阻塞，这是因为任何一个线程都是先调用take方法，然后再调用release。</p>
<p>通过有上限的Semaphore可以限制进入某代码块的线程数量。设想一下，在上面的例子中，如果BoundedSemaphore 上限设为5将会发生什么？意味着允许5个线程同时访问关键区域，但是你必须保证，这个5个线程不会互相冲突。否则你的应用程序将不能正常运行。</p>
<p>必须注意，release方法应当在finally块中被执行。这样可以保在关键区域的代码抛出异常的情况下，信号也一定会被释放。</p>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来，如从队列中移除一个或者多个元素，或者完全清空队列，下图展示了如何通过阻塞队列来合作：<br><img src="http://tutorials.jenkov.com/images/java-concurrency-utils/blocking-queue.png" alt=""><br>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素.<br>从5.0开始，JDK在java.util.concurrent包里提供了阻塞队列的官方实现。尽管JDK中已经包含了阻塞队列的官方实现，但是熟悉其背后的原理还是很有帮助的。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> List queue = <span class="keyword">new</span> LinkedList();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>  limit = <span class="number">10</span>;<span class="comment">//队列长度</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> limit)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.limit = limit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Object item)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException  &#123;</div><div class="line">       <span class="keyword">while</span>(<span class="keyword">this</span>.queue.size() == <span class="keyword">this</span>.limit) &#123;</div><div class="line">             wait();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.queue.size() == <span class="number">0</span>) &#123;</div><div class="line">            notifyAll();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.queue.add(item);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">dequeue</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.queue.size() == <span class="number">0</span>)&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.queue.size() == <span class="keyword">this</span>.limit)&#123;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.remove(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>必须注意到，在enqueue和dequeue方法内部，只有队列的大小等于上限（limit）或者下限（0）时，才调用notifyAll方法。如果队列的大小既不等于上限，也不等于下限，任何线程调用enqueue或者dequeue方法时，都不会阻塞，都能够正常的往队列中添加或者移除元素。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池（Thread Pool）对于限制应用程序中同一时刻运行的线程数很有用。因为每启动一个新线程都会有相应的性能开销，每个线程都需要给栈分配一些内存等等。</p>
<p>我们可以把并发执行的任务传递给一个线程池，来替代为每个并发执行的任务都启动一个新的线程。只要池里有空闲的线程，任务就会分配给一个线程执行。在线程池的内部，任务被插入一个阻塞队列（Blocking Queue ），线程池里的线程会去取这个队列里的任务。当一个新任务插入队列时，一个空闲线程就会成功的从队列中取出任务并且执行它。</p>
<p>线程池经常应用在多线程服务器上。每个通过网络到达服务器的连接都被包装成一个任务并且传递给线程池。线程池的线程会并发的处理连接上的请求。以后会再深入有关 Java 实现多线程服务器的细节。</p>
<p>Java 5 在 java.util.concurrent 包中自带了内置的线程池，所以你不用非得实现自己的线程池。你可以阅读我写的 java.util.concurrent.ExecutorService 的文章以了解更多有关内置线程池的知识。不过无论如何，知道一点关于线程池实现的知识总是有用的。</p>
<p>这里有一个简单的线程池实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> BlockingQueue taskQueue = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">private</span> List&lt;PoolThread&gt; threads = <span class="keyword">new</span> ArrayList&lt;PoolThread&gt;();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isStopped = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> noOfThreads, <span class="keyword">int</span> maxNoOfTasks)</span> </span>&#123;</div><div class="line">    taskQueue = <span class="keyword">new</span> BlockingQueue(maxNoOfTasks);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;noOfThreads; i++) &#123;</div><div class="line">      threads.add(<span class="keyword">new</span> PoolThread(taskQueue));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (PoolThread thread : threads) &#123;</div><div class="line">      thread.start();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">synchronized</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isStopped) <span class="keyword">throw</span></div><div class="line">      <span class="keyword">new</span> IllegalStateException(<span class="string">"ThreadPool is stopped"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.taskQueue.enqueue(task);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.isStopped = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">for</span> (PoolThread thread : threads) &#123;</div><div class="line">      thread.stop();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span>       isStopped = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PoolThread</span><span class="params">(BlockingQueue&lt;Runnable&gt; queue)</span> </span>&#123;</div><div class="line">    taskQueue = queue;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!isStopped()) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        Runnable runnable =taskQueue.take();</div><div class="line">        runnable.run();</div><div class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">        <span class="comment">// 写日志或者报告异常,</span></div><div class="line">        <span class="comment">// 但保持线程池运行.</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">toStop</span><span class="params">()</span> </span>&#123;</div><div class="line">    isStopped = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">this</span>.interrupt(); <span class="comment">// 打断池中线程的 dequeue() 调用.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isStopped</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> isStopped;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>线程池的实现由两部分组成。类 ThreadPool 是线程池的公开接口，而类 PoolThread 用来实现执行任务的子线程。</p>
<p>为了执行一个任务，方法 ThreadPool.execute(Runnable r) 用 Runnable 的实现作为调用参数。在内部，Runnable 对象被放入 阻塞队列 (Blocking Queue)，等待着被子线程取出队列。</p>
<p>一个空闲的 PoolThread 线程会把 Runnable 对象从队列中取出并执行。你可以在 PoolThread.run() 方法里看到这些代码。执行完毕后，PoolThread 进入循环并且尝试从队列中再取出一个任务，直到线程终止。</p>
<p>调用 ThreadPool.stop() 方法可以停止 ThreadPool。在内部，调用 stop 先会标记 isStopped 成员变量（为 true）。然后，线程池的每一个子线程都调用 PoolThread.stop() 方法停止运行。注意，如果线程池的 execute() 在 stop() 之后调用，execute() 方法会抛出 IllegalStateException 异常。</p>
<p>子线程会在完成当前执行的任务后停止。注意 PoolThread.stop() 方法中调用了 this.interrupt()。它确保阻塞在 taskQueue.dequeue() 里的 wait() 调用的线程能够跳出 wait() 调用（校对注：因为执行了中断interrupt，它能够打断这个调用），并且抛出一个 InterruptedException 异常离开 dequeue() 方法。这个异常在 PoolThread.run() 方法中被截获、报告，然后再检查 isStopped 变量。由于 isStopped 的值是 true, 因此 PoolThread.run() 方法退出，子线程终止。</p>
<h1 id="Java并发编程之CAS"><a href="#Java并发编程之CAS" class="headerlink" title="Java并发编程之CAS"></a>Java并发编程之CAS</h1><p>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。这听起来可能有一点复杂但是实际上你理解之后发现很简单，接下来，让我们跟深入的了解一下这项技术。</p>
<h2 id="CAS的使用场景"><a href="#CAS的使用场景" class="headerlink" title="CAS的使用场景"></a>CAS的使用场景</h2><p>在程序和算法中一个经常出现的模式就是“check and act”模式。先检查后操作模式发生在代码中首先检查一个变量的值，然后再基于这个值做一些操作。下面是一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!locked) &#123;</div><div class="line">            locked = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码，如果用在多线程的程序会出现很多错误，不过现在请忘掉它。</p>
<p>如你所见，lock()方法首先检查locked&gt;成员变量是否等于false，如果等于，就将locked设为true。</p>
<p>如果同个线程访问同一个MyLock实例，上面的lock()将不能保证正常工作。如果一个线程检查locked的值，然后将其设置为false，与此同时，一个线程B也在检查locked的值，又或者，在线程A将locked的值设为false之前。因此，线程A和线程B可能都看到locked的值为false，然后两者都基于这个信息做一些操作。</p>
<p>为了在一个多线程程序中良好的工作，”check then act” 操作必须是原子的。原子就是说”check“操作和”act“被当做一个原子代码块执行。不存在多个线程同时执行原子块。</p>
<p>下面是一个代码示例，把之前的lock()方法用synchronized关键字重构成一个原子块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!locked) &#123;</div><div class="line">            locked = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CAS用作原子操作"><a href="#CAS用作原子操作" class="headerlink" title="CAS用作原子操作"></a>CAS用作原子操作</h2><p>现在CPU内部已经执行原子的CAS操作。Java5以来，你可以使用java.util.concurrent.atomic包中的一些原子类来使用CPU中的这些功能。<br>下面是一个使用AtomicBoolean类实现lock()方法的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> AtomicBoolean locked = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> locked.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>locked变量不再是boolean类型而是AtomicBoolean。这个类中有一个compareAndSet()方法，它使用一个期望值和AtomicBoolean实例的值比较，和两者相等，则使用一个新值替换原来的值。在这个例子中，它比较locked的值和false，如果locked的值为false，则把修改为true。<br>如果值被替换了，compareAndSet()返回true，否则，返回false。</p>
<p>使用Java5+提供的CAS特性而不是使用自己实现的的好处是Java5+中内置的CAS特性可以让你利用底层的你的程序所运行机器的CPU的CAS特性。这会使还有CAS的代码运行更快。</p>
<h1 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h1><p>虽然许多同步器（如锁，信号量，阻塞队列等）功能上各不相同，但它们的内部设计上却差别不大。换句话说，它们内部的的基础部分是相同（或相似）的。了解这些基础部件能在设计同步器的时候给我们大大的帮助。这就是本文要细说的内容。</p>
<p>大部分同步器都是用来保护某个区域（临界区）的代码，这些代码可能会被多线程并发访问。要实现这个目标，同步器一般要支持下列功能：</p>
<ol>
<li>状态</li>
<li>访问条件</li>
<li>状态变化</li>
<li>通知策略</li>
<li>Test-and-Set方法</li>
<li>Set方法</li>
</ol>
<p>并不是所有同步器都包含上述部分，也有些并不完全遵照上面的内容。但通常你能从中发现这些部分的一或多个。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>同步器中的状态是用来确定某个线程是否有访问权限。在Lock中，状态是boolean类型的，表示当前Lock对象是否处于锁定状态。在BoundedSemaphore中，内部状态包含一个计数器（int类型）和一个上限（int类型），分别表示当前已经获取的许可数和最大可获取的许可数。BlockingQueue的状态是该队列中元素列表以及队列的最大容量。<br>下面是Lock和BoundedSemaphore中的两个代码片段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</div><div class="line">  <span class="comment">//state is kept here</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></div><div class="line">  <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">    <span class="keyword">while</span>(isLocked)&#123;</div><div class="line">      wait();</div><div class="line">    &#125;</div><div class="line">    isLocked = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span> </span>&#123;</div><div class="line">  <span class="comment">//state is kept here</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> bound   = <span class="number">0</span>;</div><div class="line">      </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSemaphore</span><span class="params">(<span class="keyword">int</span> upperBound)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.bound = upperBound;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == bound) wait();</div><div class="line">    <span class="keyword">this</span>.signal++;</div><div class="line">    <span class="keyword">this</span>.notify();</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="访问条件"><a href="#访问条件" class="headerlink" title="访问条件"></a>访问条件</h2><p>访问条件决定调用test-and-set-state方法的线程是否可以对状态进行设置。访问条件一般是基于同步器状态的。通常是放在一个while循环里，以避免虚假唤醒问题。访问条件的计算结果要么是true要么是false。</p>
<p>Lock中的访问条件只是简单地检查isLocked的值。根据执行的动作是“获取”还是“释放”，BoundedSemaphore中实际上有两个访问条件。如果某个线程想“获取”许可，将检查signals变量是否达到上限；如果某个线程想“释放”许可，将检查signals变量是否为0。</p>
<p>这里有两个来自Lock和BoundedSemaphore的代码片段，它们都有访问条件。注意观察条件是怎样在while循环中检查的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></div><div class="line">  <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">    <span class="comment">//access condition</span></div><div class="line">    <span class="keyword">while</span>(isLocked)&#123;</div><div class="line">      wait();</div><div class="line">    &#125;</div><div class="line">    isLocked = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> bound = <span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSemaphore</span><span class="params">(<span class="keyword">int</span> upperBound)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.bound = upperBound;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    <span class="comment">//access condition</span></div><div class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == bound) wait();</div><div class="line">    <span class="keyword">this</span>.signals++;</div><div class="line">    <span class="keyword">this</span>.notify();</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    <span class="comment">//access condition</span></div><div class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == <span class="number">0</span>) wait();</div><div class="line">    <span class="keyword">this</span>.signals--;</div><div class="line">    <span class="keyword">this</span>.notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h2><p>一旦一个线程获得了临界区的访问权限，它得改变同步器的状态，让其它线程阻塞，防止它们进入临界区。换而言之，这个状态表示正有一个线程在执行临界区的代码。其它线程想要访问临界区的时候，该状态应该影响到访问条件的结果。</p>
<p>在Lock中，通过代码设置isLocked = true来改变状态，在信号量中，改变状态的是signals–或signals++;</p>
<p>这里有两个状态变化的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></div><div class="line">  <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">    <span class="keyword">while</span>(isLocked)&#123;</div><div class="line">      wait();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//state change</span></div><div class="line">    isLocked = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//state change</span></div><div class="line">    isLocked = <span class="keyword">false</span>;</div><div class="line">    notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> bound   = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSemaphore</span><span class="params">(<span class="keyword">int</span> upperBound)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.bound = upperBound;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == bound) wait();</div><div class="line">    <span class="comment">//state change</span></div><div class="line">    <span class="keyword">this</span>.signals++;</div><div class="line">    <span class="keyword">this</span>.notify();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == <span class="number">0</span>) wait();</div><div class="line">    <span class="comment">//state change</span></div><div class="line">    <span class="keyword">this</span>.signals--;</div><div class="line">    <span class="keyword">this</span>.notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="通知策略"><a href="#通知策略" class="headerlink" title="通知策略"></a>通知策略</h2><p>一旦某个线程改变了同步器的状态，可能需要通知其它等待的线程状态已经变了。因为也许这个状态的变化会让其它线程的访问条件变为true。</p>
<p>通知策略通常分为三种：</p>
<ol>
<li>通知所有等待的线程</li>
<li>通知N个等待线程中的任意一个</li>
<li>通知N个等待线程中的某个指定的线程</li>
</ol>
<p>通知所有等待的线程非常简单。所有等待的线程都调用的同一个对象上的wait()方法，某个线程想要通知它们只需在这个对象上调用notifyAll()方法。</p>
<p>通知等待线程中的任意一个也很简单，只需将notifyAll()调用换成notify()即可。调用notify方法没办法确定唤醒的是哪一个线程，也就是“等待线程中的任意一个”。</p>
<p>有时候可能需要通知指定的线程而非任意一个等待的线程。例如，如果你想保证线程被通知的顺序与它们进入同步块的顺序一致，或按某种优先级的顺序来通知。想要实现这种需求，每个等待的线程必须在其自有的对象上调用wait()。当通知线程想要通知某个特定的等待线程时，调用该线程自有对象的notify()方法即可。饥饿和公平中有这样的例子。</p>
<h2 id="Test-and-Set方法"><a href="#Test-and-Set方法" class="headerlink" title="Test-and-Set方法"></a>Test-and-Set方法</h2><p>同步器中最常见的有两种类型的方法，test-and-set是第一种（set是另一种）。Test-and-set的意思是，调用这个方法的线程检查访问条件，如若满足，该线程设置同步器的内部状态来表示它已经获得了访问权限。</p>
<p>状态的改变通常使其它试图获取访问权限的线程计算条件状态时得到false的结果，但并不一定总是如此。例如，在读写锁中，获取读锁的线程会更新读写锁的状态来表示它获取到了读锁，但是，只要没有线程请求写锁，其它请求读锁的线程也能成功。</p>
<p>test-and-set很有必要是原子的，也就是说在某个线程检查和设置状态期间，不允许有其它线程在test-and-set方法中执行。</p>
<p>test-and-set方法的程序流通常遵照下面的顺序：</p>
<ol>
<li>如有必要，在检查前先设置状态</li>
<li>检查访问条件</li>
<li>如果访问条件不满足，则等待</li>
<li>如果访问条件满足，设置状态，如有必要还要通知等待线程</li>
</ol>
<p>下面的ReadWriteLock类的lockWrite()方法展示了test-and-set方法。调用lockWrite()的线程在检查之前先设置状态(writeRequests++)。然后检查canGrantWriteAccess()中的访问条件，如果检查通过，在退出方法之前再次设置内部状态。这个方法中没有去通知等待线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Thread, Integer&gt; readingThreads =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;Thread, Integer&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeAccesses    = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writeRequests    = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> Thread writingThread = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">      writeRequests++;</div><div class="line">      Thread callingThread = Thread.currentThread();</div><div class="line">      <span class="keyword">while</span>(! canGrantWriteAccess(callingThread))&#123;</div><div class="line">        wait();</div><div class="line">      &#125;</div><div class="line">      writeRequests--;</div><div class="line">      writeAccesses++;</div><div class="line">      writingThread = callingThread;</div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的BoundedSemaphore类有两个test-and-set方法：take()和release()。两个方法都有检查和设置内部状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> bound   = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSemaphore</span><span class="params">(<span class="keyword">int</span> upperBound)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.bound = upperBound;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == bound) wait();</div><div class="line">    <span class="keyword">this</span>.signals++;</div><div class="line">    <span class="keyword">this</span>.notify();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == <span class="number">0</span>) wait();</div><div class="line">    <span class="keyword">this</span>.signals--;</div><div class="line">    <span class="keyword">this</span>.notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Set方法"><a href="#Set方法" class="headerlink" title="Set方法"></a>Set方法</h2><p>set方法是同步器中常见的第二种方法。set方法仅是设置同步器的内部状态，而不先做检查。set方法的一个典型例子是Lock类中的unlock()方法。持有锁的某个线程总是能够成功解锁，而不需要检查该锁是否处于解锁状态。</p>
<p>set方法的程序流通常如下：</p>
<ol>
<li>设置内部状态</li>
<li>通知等待的线程</li>
</ol>
<p>这里是unlock()方法的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</div><div class="line">    isLocked = <span class="keyword">false</span>;</div><div class="line">    notify();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h1><p>在并发上下文中，非阻塞算法是一种允许线程在阻塞其他线程的情况下访问共享状态的算法。在绝大多数项目中，在算法中如果一个线程的挂起没有导致其它的线程挂起，我们就说这个算法是非阻塞的。</p>
<p>为了更好的理解阻塞算法和非阻塞算法之间的区别，我会先讲解阻塞算法然后再讲解非阻塞算法。</p>
<h2 id="阻塞并发算法"><a href="#阻塞并发算法" class="headerlink" title="阻塞并发算法"></a>阻塞并发算法</h2><p>一个阻塞并发算法一般分下面两步：</p>
<ul>
<li>执行线程请求的操作</li>
<li>阻塞线程直到可以安全地执行操作<br>很多算法和并发数据结构都是阻塞的。例如，java.util.concurrent.BlockingQueue的不同实现都是阻塞数据结构。如果一个线程要往一个阻塞队列中插入一个元素，队列中没有足够的空间，执行插入操作的线程就会阻塞直到队列中有了可以存放插入元素的空间。</li>
</ul>
<p>下图演示了一个阻塞算法保证一个共享数据结构的行为：<br><img src="https://camo.githubusercontent.com/720fd34b938c645d6d42b41e5d694fb9d2d71a61/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d312e706e67" alt=""></p>
<h2 id="阻塞并发算法-1"><a href="#阻塞并发算法-1" class="headerlink" title="阻塞并发算法"></a>阻塞并发算法</h2><p>一个非阻塞并发算法一般包含下面两步：</p>
<ul>
<li>执行线程请求的操作</li>
<li>通知请求线程操作不能被执行<br>Java也包含几个非阻塞数据结构。<br>AtomicBoolean,AtomicInteger,AtomicLong,AtomicReference都是非阻塞数据结构的例子。</li>
</ul>
<p>下图演示了一个非阻塞算法保证一个共享数据结构的行为：<br><img src="https://camo.githubusercontent.com/3f3647ee8e4af4140e5414eb296d8f2d4e83a3fb/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d322e706e67" alt=""></p>
<p>##　非阻塞算法 vs 阻塞算法<br>阻塞算法和非阻塞算法的主要不同在于上面两部分描述的它们的行为的第二步。换句话说，它们之间的不同在于当请求操作不能够执行时阻塞算法和非阻塞算法会怎么做。</p>
<p>阻塞算法会阻塞线程知道请求操作可以被执行。非阻塞算法会通知请求线程操作不能够被执行，并返回。</p>
<p>一个使用了阻塞算法的线程可能会阻塞直到有可能去处理请求。通常，其它线程的动作使第一个线程执行请求的动作成为了可能。 如果，由于某些原因线程被阻塞在程序某处，因此不能让第一个线程的请求动作被执行，第一个线程会阻塞——可能一直阻塞或者直到其他线程执行完必要的动作。</p>
<p>例如，如果一个线程产生往一个已经满了的阻塞队列里插入一个元素，这个线程就会阻塞，直到其他线程从这个阻塞队列中取走了一些元素。如果由于某些原因，从阻塞队列中取元素的线程假定被阻塞在了程序的某处，那么，尝试往阻塞队列中添加新元素的线程就会阻塞，要么一直阻塞下去，要么知道从阻塞队列中取元素的线程最终从阻塞队列中取走了一个元素。</p>
<h2 id="非阻塞并发数据结构"><a href="#非阻塞并发数据结构" class="headerlink" title="非阻塞并发数据结构"></a>非阻塞并发数据结构</h2><p>在一个多线程系统中，线程间通常通过一些数据结构”交流“。例如可以是任何的数据结构，从变量到更高级的俄数据结构（队列，栈等）。为了确保正确，并发线程在访问这些数据结构的时候，这些数据结构必须由一些并发算法来保证。这些并发算法让这些数据结构成为并发数据结构。</p>
<p>如果某个算法确保一个并发数据结构是阻塞的，它就被称为是一个阻塞算法。这个数据结构也被称为是一个阻塞，并发数据结构。</p>
<p>如果某个算法确保一个并发数据结构是非阻塞的，它就被称为是一个非阻塞算法。这个数据结构也被称为是一个非阻塞，并发数据结构。</p>
<p>每个并发数据结构被设计用来支持一个特定的通信方法。使用哪种并发数据结构取决于你的通信需要。在接下里的部分，我会引入一些非阻塞并发数据结构，并讲解它们各自的适用场景。通过这些并发数据结构工作原理的讲解应该能在非阻塞数据结构的设计和实现上一些启发。</p>
<p>###　Volatile 变量<br>Java中的volatile变量是直接从主存中读取值的变量。当一个新的值赋给一个volatile变量时，这个值总是会被立即写回到主存中去。这样就确保了，一个volatile变量最新的值总是对跑在其他CPU上的线程可见。其他线程每次会从主存中读取变量的值，而不是比如线程所运行CPU的CPU缓存中。</p>
<p>ｖolatile变量是非阻塞的。修改一个volatile变量的值是原子操作。它不能够被中断。不过，在一个volatile变量上的一个 read-update-write 顺序的操作不是原子的。因此，下面的代码如果由多个线程执行可能导致竞态条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> myVar = <span class="number">0</span>;</div><div class="line">...</div><div class="line"><span class="keyword">int</span> temp = myVar;</div><div class="line">temp++;</div><div class="line">myVar = temp;</div></pre></td></tr></table></figure>
<p>首先，myVar这个volatile变量的值被从主存中读出来赋给了temp变量。然后，temp变量自增1。然后，temp变量的值又赋给了myVar这个volatile变量这意味着它会被写回到主存中。</p>
<p>如果两个线程执行这段代码，然后它们都读取myVar的值，加1后，把它的值写回到主存。这样就存在myVar仅被加1，而没有被加2的风险。<br>你可能认为你不会写像上面这样的代码，但是在实践中上面的代码等同于如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myVar++;</div></pre></td></tr></table></figure>
<p>执行上面的代码时，myVar的值读到一个CPU寄存器或者一个本地CPU缓存中，myVar加1，然后这个CPU寄存器或者CPU缓存中的值被写回到主存中。</p>
<p>###　单个写线程的情景<br>在一些场景下，你仅有一个线程在向一个共享变量写，多个线程在读这个变量。当仅有一个线程在更新一个变量，不管有多少个线程在读这个变量，都不会发生竞态条件。因此，当仅有一个线程在写一个共享变量时，你可以把这个变量声明为volatile。</p>
<p>当多个线程在一个共享变量上执行一个 read-update-write 的顺序操作时才会发生竞态条件。如果你只有一个线程在执行一个 raed-update-write 的顺序操作，其他线程都在执行读操作，将不会发生竞态条件。</p>
<p>下面是一个单个写线程的例子，它没有采取同步手段但仍然是并发的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleWriterCounter</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> count = <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *Only one thread may ever call this method</div><div class="line">     *or it will lead to race conditions</div><div class="line">     */</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">this</span>.count++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      *Many reading threads may call this method</div><div class="line">      *<span class="doctag">@return</span></div><div class="line">      */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.count;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多个线程访问同一个Counter实例，只要仅有一个线程调用inc()方法，这里，我不是说在某一时刻一个线程，我的意思是，仅有相同的，单个的线程被允许去调用inc()&gt;方法。多个线程可以调用count()方法。这样的场景将不会发生任何竞态条件。<br>下图，说明了线程是如何访问count这个volatile变量的。<br><img src="https://camo.githubusercontent.com/74cd8d994d0be5bee55c55c72b3ce86a673cf86f/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d332e706e67" alt=""></p>
<h3 id="基于volatile变量更高级的数据结构"><a href="#基于volatile变量更高级的数据结构" class="headerlink" title="基于volatile变量更高级的数据结构"></a>基于volatile变量更高级的数据结构</h3><p>使用多个volatile变量去创建数据结构是可以的，构建出的数据结构中每一个volatile变量仅被一个单个的线程写，被多个线程读。每个volatile变量可能被一个不同的线程写（但仅有一个）。使用像这样的数据结构多个线程可以使用这些volatile变量以一个非阻塞的方法彼此发送信息。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleWriterCounter</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> countA = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> countB = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *Only one (and the same from thereon) thread may ever call this method,</div><div class="line">     *or it will lead to race conditions.</div><div class="line">     */</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incA</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">this</span>.countA++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      *Only one (and the same from thereon) thread may ever call this method, </div><div class="line">      *or it will  lead to race conditions.</div><div class="line">      */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incB</span><span class="params">()</span></span>&#123;</div><div class="line">          <span class="keyword">this</span>.countB++;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       *Many reading threads may call this method</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countA</span><span class="params">()</span></span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.countA;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      *Many reading threads may call this method</div><div class="line">      */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countB</span><span class="params">()</span></span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.countB;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所见，DoubleWriterCoounter现在包含两个volatile变量以及两对自增和读方法。在某一时刻，仅有一个单个的线程可以调用inc()，仅有一个单个的线程可以访问incB()。不过不同的线程可以同时调用incA()和incB()。countA()和countB()可以被多个线程调用。这将不会引发竞态条件。</p>
<p>DoubleWriterCoounter可以被用来比如线程间通信。countA和countB可以分别用来存储生产的任务数和消费的任务数。下图，展示了两个线程通过类似于上面的一个数据结构进行通信的。<br><img src="https://camo.githubusercontent.com/97a2b4ea28a6d8fb79460d847acf047603c3b975/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d342e706e67" alt=""><br>聪明的读者应该已经意识到使用两个SingleWriterCounter可以达到使用DoubleWriterCoounter的效果。如果需要，你甚至可以使用多个线程和SingleWriterCounter实例。</p>
<h2 id="使用CAS的乐观锁"><a href="#使用CAS的乐观锁" class="headerlink" title="使用CAS的乐观锁"></a>使用CAS的乐观锁</h2><p>如果你确实需要多个线程区写同一个共享变量，volatile变量是不合适的。你将会需要一些类型的排它锁（悲观锁）访问这个变量。下面代码演示了使用Java中的同步块进行排他访问的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，，inc()和count()方法都包含一个同步块。这也是我们想避免的东西——同步块和 wait()-notify 调用等。<br>我们可以使用一种Java的原子变量来代替这两个同步块。在这个例子是AtomicLong。下面是SynchronizedCounter类的AtomicLong实现版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">boolean</span> updated = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">while</span>(!updated)&#123;</div><div class="line">            <span class="keyword">long</span> prevCount = <span class="keyword">this</span>.count.get();</div><div class="line">            updated = <span class="keyword">this</span>.count.compareAndSet(prevCount, prevCount + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个版本仅仅是上一个版本的线程安全版本。这一版我们感兴趣的是inc()方法的实现。inc()方法中不再含有一个同步块。而是被下面这些代码替代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> updated = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">while</span>(!updated)&#123;</div><div class="line">    <span class="keyword">long</span> prevCount = <span class="keyword">this</span>.count.get();</div><div class="line">    updated = <span class="keyword">this</span>.count.compareAndSet(prevCount, prevCount + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这些代码并不是一个原子操作。也就是说，对于两个不同的线程去调用inc()方法，然后执行long prevCount = this.count.get()语句，因此获得了这个计数器的上一个count。但是，上面的代码并没有包含任何的竞态条件。</p>
<p>秘密就在于while循环里的第二行代码。compareAndSet()方法调用是一个原子操作。它用一个期望值和AtomicLong 内部的值去比较，如果这两个值相等，就把AtomicLong内部值替换为一个新值。compareAndSet()通常被CPU中的compare-and-swap指令直接支持。因此，不需要去同步，也不需要去挂起线程。</p>
<p>假设，这个AtomicLong的内部值是20,。然后，两个线程去读这个值，都尝试调用compareAndSet(20, 20 + 1)。尽管compareAndSet()是一个原子操作，这个方法也会被这两个线程相继执行（某一个时刻只有一个）。</p>
<p>第一个线程会使用期望值20（这个计数器的上一个值）与AtomicLong的内部值进行比较。由于两个值是相等的，AtomicLong会更新它的内部值至21（20 + 1 ）。变量updated被修改为true，while循环结束。</p>
<p>现在，第二个线程调用compareAndSet(20, 20 + 1)。由于AtomicLong的内部值不再是20，这个调用将不会成功。AtomicLong的值不会再被修改为21。变量，updated被修改为false，线程将会再次在while循环外自旋。这段时间，它会读到值21并企图把值更新为22。如果在此期间没有其它线程调用inc()。第二次迭代将会成功更新AtomicLong的内部值到22。</p>
<h3 id="为什么称它为乐观锁"><a href="#为什么称它为乐观锁" class="headerlink" title="为什么称它为乐观锁"></a>为什么称它为乐观锁</h3><p>上一部分展现的代码被称为乐观锁（optimistic locking）。乐观锁区别于传统的锁(有时也被称为悲观锁)。传统的锁会使用同步块或其他类型的锁阻塞对临界区域的访问。一个同步块或锁可能会导致线程挂起。</p>
<p>乐观锁允许所有的线程在不发生阻塞的情况下创建一份共享内存的拷贝。这些线程接下来可能会对它们的拷贝进行修改，并企图把它们修改后的版本写回到共享内存中。如果没有其它线程对共享内存做任何修改， CAS操作就允许线程将它的变化写回到共享内存中去。如果，另一个线程已经修改了共享内存，这个线程将不得不再次获得一个新的拷贝，在新的拷贝上做出修改，并尝试再次把它们写回到共享内存中去。</p>
<p>称之为“乐观锁”的原因就是，线程获得它们想修改的数据的拷贝并做出修改，在乐观的假在此期间没有线程对共享内存做出修改的情况下。当这个乐观假设成立时，这个线程仅仅在无锁的情况下完成共享内存的更新。当这个假设不成立时，线程所做的工作就会被丢弃，但仍然不使用锁。</p>
<p>乐观锁使用于共享内存竞用不是非常高的情况。如果共享内存上的内容非常多，仅仅因为更新共享内存失败，就用浪费大量的CPU周期用在拷贝和修改上。但是，如果在共享内存上有大量的内容，无论如何，你都要把你的代码设计的产生的争用更低。</p>
<h3 id="乐观锁是非阻塞的"><a href="#乐观锁是非阻塞的" class="headerlink" title="乐观锁是非阻塞的"></a>乐观锁是非阻塞的</h3><p>我们这里提到的乐观锁机制是非阻塞的。如果一个线程获得了一份共享内存的拷贝，当尝试修改时，发生了阻塞，其它线程去访问这块内存区域不会发生阻塞。</p>
<p>对于一个传统的加锁/解锁模式，当一个线程持有一个锁时，其它所有的线程都会一直阻塞直到持有锁的线程再次释放掉这个锁。如果持有锁的这个线程被阻塞在某处，这个锁将很长一段时间不能被释放，甚至可能一直不能被释放。</p>
<h2 id="不可替换的数据结构"><a href="#不可替换的数据结构" class="headerlink" title="不可替换的数据结构"></a>不可替换的数据结构</h2><p>简单的CAS乐观锁可以用于共享数据结果，这样一来，整个数据结构都可以通过一个单个的CAS操作被替换成为一个新的数据结构。尽管，使用一个修改后的拷贝来替换真个数据结构并不总是可行的。</p>
<p>假设，这个共享数据结构是队列。每当线程尝试从向队列中插入或从队列中取出元素时，都必须拷贝这个队列然后在拷贝上做出期望的修改。我们可以通过使用一个AtomicReference来达到同样的目的。拷贝引用，拷贝和修改队列，尝试替换在AtomicReference中的引用让它指向新创建的队列。</p>
<p>然而，一个大的数据结构可能会需要大量的内存和CPU周期来复制。这会使你的程序占用大量的内存和浪费大量的时间再拷贝操作上。这将会降低你的程序的性能，特别是这个数据结构的竞用非常高情况下。更进一步说，一个线程花费在拷贝和修改这个数据结构上的时间越长，其它线程在此期间修改这个数据结构的可能性就越大。如你所知，如果另一个线程修改了这个数据结构在它被拷贝后，其它所有的线程都不等不再次执行 拷贝-修改 操作。这将会增大性能影响和内存浪费，甚至更多。</p>
<p>接下来的部分将会讲解一种实现非阻塞数据结构的方法，这种数据结构可以被并发修改，而不仅仅是拷贝和修改。</p>
<h3 id="共享预期的修改"><a href="#共享预期的修改" class="headerlink" title="共享预期的修改"></a>共享预期的修改</h3><p>用来替换拷贝和修改整个数据结构，一个线程可以共享它们对共享数据结构预期的修改。一个线程向对修改某个数据结构的过程变成了下面这样：</p>
<ul>
<li>检查是否另一个线程已经提交了对这个数据结构提交了修改</li>
<li>如果没有其他线程提交了一个预期的修改，创建一个预期的修改，然后向这个数据结构提交预期的修改</li>
<li>执行对共享数据结构的修改</li>
<li>移除对这个预期的修改的引用，向其它线程发送信号，告诉它们这个预期的修改已经被执行<br>如你所见，第二步可以阻塞其他线程提交一个预期的修改。因此，第二步实际的工作是作为这个数据结构的一个锁。如果一个线程已经成功提交了一个预期的修改，其他线程就不可以再提交一个预期的修改直到第一个预期的修改执行完毕。</li>
</ul>
<p>如果一个线程提交了一个预期的修改，然后做一些其它的工作时发生阻塞，这时候，这个共享数据结构实际上是被锁住的。其它线程可以检测到它们不能够提交一个预期的修改，然后回去做一些其它的事情。很明显，我们需要解决这个问题。</p>
<h3 id="可完成的预期修改"><a href="#可完成的预期修改" class="headerlink" title="可完成的预期修改"></a>可完成的预期修改</h3><p>为了避免一个已经提交的预期修改可以锁住共享数据结构，一个已经提交的预期修改必须包含足够的信息让其他线程来完成这次修改。因此，如果一个提交了预期修改的线程从未完成这次修改，其他线程可以在它的支持下完成这次修改，保证这个共享数据结构对其他线程可用。</p>
<p>下图说明了上面描述的非阻塞算法的蓝图：<br><img src="https://camo.githubusercontent.com/c4d52cd702c9ad3124a62a76ee9493da43d07562/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d352e706e67" alt=""><br>修改必须被当做一个或多个CAS操作来执行。因此，如果两个线程尝试去完成同一个预期修改，仅有一个线程可以所有的CAS操作。一旦一条CAS操作完成后，再次企图完成这个CAS操作都不会“得逞”。</p>
<h3 id="A-B-A问题"><a href="#A-B-A问题" class="headerlink" title="A-B-A问题"></a>A-B-A问题</h3><p>上面演示的算法可以称之为A-B-A问题。A-B-A问题指的是一个变量被从A修改到了B，然后又被修改回A的一种情景。其他线程对于这种情况却一无所知。</p>
<p>如果线程A检查正在进行的数据更新，拷贝，被线程调度器挂起，一个线程B在此期可能可以访问这个共享数据结构。如果线程对这个数据结构执行了全部的更新，移除了它的预期修改，这样看起来，好像线程A自从拷贝了这个数据结构以来没有对它做任何的修改。然而，一个修改确实已经发生了。当线程A继续基于现在已经过期的数据拷贝执行它的更新时，这个数据修改已经被线程B的修改破坏。</p>
<p>下图说明了上面提到的A-B-A问题：<br><img src="https://camo.githubusercontent.com/e8ddaa9c30791bc7ed8f09c92585cb11b724558c/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6e6f6e2d626c6f636b696e672d616c676f726974686d732d362e706e67" alt=""></p>
<h3 id="A-B-A问题的解决方案"><a href="#A-B-A问题的解决方案" class="headerlink" title="A-B-A问题的解决方案"></a>A-B-A问题的解决方案</h3><p>A-B-A通常的解决方法就是不再仅仅替换指向一个预期修改对象的指针，而是指针结合一个计数器，然后使用一个单个的CAS操作来替换指针 + 计数器。这在支持指针的语言像C和C++中是可行的。因此，尽管当前修改指针被设置回指向 “不是正在进行的修改”（no ongoing modification），指针 + 计数器的计数器部分将会被自增，使修改对其它线程是可见的。</p>
<p>在Java中，你不能将一个引用和一个计数器归并在一起形成一个单个的变量。不过Java提供了AtomicStampedReference类，利用这个类可以使用一个CAS操作自动的替换一个引用和一个标记（stamp）。</p>
<h2 id="一个非阻塞算法模板"><a href="#一个非阻塞算法模板" class="headerlink" title="一个非阻塞算法模板"></a>一个非阻塞算法模板</h2><h2 id="非阻塞算法是不容易实现的"><a href="#非阻塞算法是不容易实现的" class="headerlink" title="非阻塞算法是不容易实现的"></a>非阻塞算法是不容易实现的</h2><p>正确的设计和实现非阻塞算法是不容易的。在尝试设计你的非阻塞算法之前，看一看是否已经有人设计了一种非阻塞算法正满足你的需求。</p>
<p>Java已经提供了一些非阻塞实现（比如 ConcurrentLinkedQueue），相信在Java未来的版本中会带来更多的非阻塞算法的实现。</p>
<p>除了Java内置非阻塞数据结构还有很多开源的非阻塞数据结构可以使用。例如，LAMX Disrupter和Cliff Click实现的非阻塞 HashMap。查看我的Java concurrency references page查看更多的资源。</p>
<h2 id="使用非阻塞算法的好处"><a href="#使用非阻塞算法的好处" class="headerlink" title="使用非阻塞算法的好处"></a>使用非阻塞算法的好处</h2><p>非阻塞算法和阻塞算法相比有几个好处。下面让我们分别看一下：</p>
<ol>
<li>选择</li>
</ol>
<p>非阻塞算法的第一个好处是，给了线程一个选择当它们请求的动作不能够被执行时做些什么。不再是被阻塞在那，请求线程关于做什么有了一个选择。有时候，一个线程什么也不能做。在这种情况下，它可以选择阻塞或自我等待，像这样把CPU的使用权让给其它的任务。不过至少给了请求线程一个选择的机会。</p>
<p>在一个单个的CPU系统可能会挂起一个不能执行请求动作的线程，这样可以让其它线程获得CPU的使用权。不过即使在一个单个的CPU系统阻塞可能导致死锁，线程饥饿等并发问题。</p>
<ol>
<li>没有死锁</li>
</ol>
<p>非阻塞算法的第二个好处是，一个线程的挂起不能导致其它线程挂起。这也意味着不会发生死锁。两个线程不能互相彼此等待来获得被对方持有的锁。因为线程不会阻塞当它们不能执行它们的请求动作时，它们不能阻塞互相等待。非阻塞算法任然可能产生活锁（live lock），两个线程一直请求一些动作，但一直被告知不能够被执行（因为其他线程的动作）。</p>
<ol>
<li>没有线程挂起</li>
</ol>
<p>挂起和恢复一个线程的代价是昂贵的。没错，随着时间的推移，操作系统和线程库已经越来越高效，线程挂起和恢复的成本也不断降低。不过，线程的挂起和户对任然需要付出很高的代价。</p>
<p>无论什么时候，一个线程阻塞，就会被挂起。因此，引起了线程挂起和恢复过载。由于使用非阻塞算法线程不会被挂起，这种过载就不会发生。这就意味着CPU有可能花更多时间在执行实际的业务逻辑上而不是上下文切换。</p>
<p>在一个多个CPU的系统上，阻塞算法会对阻塞算法产生重要的影响。运行在CPUA上的一个线程阻塞等待运行在CPU B上的一个线程。这就降低了程序天生就具备的并行水平。当然，CPU A可以调度其他线程去运行，但是挂起和激活线程（上下文切换）的代价是昂贵的。需要挂起的线程越少越好。</p>
<ol>
<li>降低线程延迟</li>
</ol>
<p>在这里我们提到的延迟指的是一个请求产生到线程实际的执行它之间的时间。因为在非阻塞算法中线程不会被挂起，它们就不需要付昂贵的，缓慢的线程激活成本。这就意味着当一个请求执行时可以得到更快的响应，减少它们的响应延迟。</p>
<p>非阻塞算法通常忙等待直到请求动作可以被执行来降低延迟。当然，在一个非阻塞数据数据结构有着很高的线程争用的系统中，CPU可能在它们忙等待期间停止消耗大量的CPU周期。这一点需要牢牢记住。非阻塞算法可能不是最好的选择如果你的数据结构哦有着很高的线程争用。不过，也常常存在通过重构你的程序来达到更低的线程争用。</p>
<h1 id="阿姆达定律"><a href="#阿姆达定律" class="headerlink" title="阿姆达定律"></a>阿姆达定律</h1><p>阿姆达尔定律可以用来计算处理器平行运算之后效率提升的能力。阿姆达尔定律因Gene Amdal 在1967年提出这个定律而得名。绝大多数使用并行或并发系统的开发者有一种并发或并行可能会带来提速的感觉，甚至不知道阿姆达尔定律。不管怎样，了解阿姆达尔定律还是有用的。<br>我会首先以算术的方式介绍阿姆达尔定律定律，然后再用图表演示一下。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个程序（或者一个算法）可以按照是否可以被并行化分为下面两个部分：</p>
<ul>
<li>可以被并行化的部分</li>
<li>不可以被并行化的部分<br>假设一个程序处理磁盘上的文件。这个程序的一小部分用来扫描路径和在内存中创建文件目录。做完这些后，每个文件交个一个单独的线程去处理。扫描路径和创建文件目录的部分不可以被并行化，不过处理文件的过程可以。</li>
</ul>
<p>程序串行（非并行）执行的总时间我们记为T。时间T包括不可以被并行和可以被并行部分的时间。不可以被并行的部分我们记为B。那么可以被并行的部分就是T-B。下面的列表总结了这些定义：</p>
<p>T = 串行执行的总时间<br>B = 不可以并行的总时间<br>T- B = 并行部分的总时间<br>从上面可以得出：</p>
<p>T = B + (T – B)</p>
<p>首先，这个看起来可能有一点奇怪，程序的可并行部分在上面这个公式中并没有自己的标识。然而，由于这个公式中可并行可以用总时间T 和 B（不可并行部分）表示出来，这个公式实际上已经从概念上得到了简化，也即是指以这种方式减少了变量的个数。</p>
<p>T- B 是可并行化的部分，以并行的方式执行可以提高程序的运行速度。可以提速多少取决于有多少线程或者多少个CPU来执行。线程或者CPU的个数我们记为N。可并行化部分被执行的最快时间可以通过下面的公式计算出来：</p>
<p>(T – B ) / N</p>
<p>或者通过这种方式</p>
<p>(1 / N) * (T – B)</p>
<p>维基中使用的是第二种方式。</p>
<p>根据阿姆达尔定律，当一个程序的可并行部分使用N个线程或CPU执行时，执行的总时间为：</p>
<p>T(N) = B + ( T – B ) / N</p>
<p>T(N)指的是在并行因子为N时的总执行时间。因此，T(1)就执行在并行因子为1时程序的总执行时间。使用T(1)代替T，阿姆达尔定律定律看起来像这样：</p>
<p>T(N) = B + (T(1) – B) / N</p>
<p>表达的意思都是是一样的。</p>
<h2 id="计算例子"><a href="#计算例子" class="headerlink" title="计算例子"></a>计算例子</h2><p>为了更好的理解阿姆达尔定律，让我们来看一个计算的例子。执行一个程序的总时间设为1.程序的不可并行化占40%，按总时间1计算，就是0.4.可并行部分就是1 – 0.4 = 0.6.</p>
<p>在并行因子为2的情况下，程序的执行时间将会是：</p>
<p>T(2) = 0.4 + ( 1 - 0.4 ) / 2<br> = 0.4 + 0.6 / 2<br> = 0.4 + 0.3<br> = 0.7<br>在并行因子为5的情况下，程序的执行时间将会是：</p>
<p>T(5) = 0.4 + ( 1 - 0.4 ) / 5<br> = 0.4 + 0.6 / 6<br> = 0.4 + 0.12<br> = 0.52</p>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p>为了更好地理解阿姆达尔定律，我会尝试演示这个定定律是如何诞生的。</p>
<p>首先，一个程序可以被分割为两部分，一部分为不可并行部分B，一部分为可并行部分1 – B。如下图：<br><img src="https://camo.githubusercontent.com/f9261b92dd8f8f5e9b8f26c9234f0aec66cfb012/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f616d6461686c732d6c61772d312e706e67" alt=""><br>在顶部被带有分割线的那条直线代表总时间 T(1)。</p>
<p>下面你可以看到在并行因子为2的情况下的执行时间：<br><img src="https://camo.githubusercontent.com/0117abdf5ee0ce2c427d65957c4e3a0479738f98/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f616d6461686c732d6c61772d322e706e67" alt=""></p>
<h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><p>从阿姆达尔定律可以看出，程序的可并行化部分可以通过使用更多的硬件（更多的线程或CPU）运行更快。对于不可并行化的部分，只能通过优化代码来达到提速的目的。因此，你可以通过优化不可并行化部分来提高你的程序的运行速度和并行能力。你可以对不可并行化在算法上做一点改动，如果有可能，你也可以把一些移到可并行化放的部分。</p>
<h3 id="优化串行分量"><a href="#优化串行分量" class="headerlink" title="优化串行分量"></a>优化串行分量</h3><p>如果你优化一个程序的串行化部分，你也可以使用阿姆达尔定律来计算程序优化后的执行时间。如果不可并行部分通过一个因子O来优化，那么阿姆达尔定律看起来就像这样：</p>
<p>T(O, N) = B / O + (1 - B / O) / N<br>记住，现在程序的不可并行化部分占了B / O的时间，所以，可并行化部分就占了1 - B / O的时间.</p>
<p>如果B为0.1，O为2，N为5，计算看起来就像这样：</p>
<p>T(2,5) = 0.4 / 2 + (1 - 0.4 / 2) / 5<br>   = 0.2 + (1 - 0.4 / 2) / 5<br>   = 0.2 + (1 - 0.2) / 5<br>   = 0.2 + 0.8 / 5<br>   = 0.2 + 0.16<br>   = 0.36</p>
<h2 id="运行时间-vs-加速"><a href="#运行时间-vs-加速" class="headerlink" title="运行时间 vs. 加速"></a>运行时间 vs. 加速</h2><p>到目前为止，我们只用阿姆达尔定律计算了一个程序或算法在优化后或者并行化后的执行时间。我们也可以使用阿姆达尔定律计算加速比（speedup），也就是经过优化后或者串行化后的程序或算法比原来快了多少。</p>
<p>如果旧版本的程序或算法的执行时间为T，那么增速比就是：</p>
<p>Speedup = T / T(O , N);<br>为了计算执行时间，我们常常把T设为1，加速比为原来时间的一个分数。公式大致像下面这样：</p>
<p>Speedup = 1 / T（O,N)<br>如果我们使用阿姆达尔定律来代替T(O,N)，我们可以得到下面的公式：</p>
<p>Speedup = 1 / ( B / O + (1 - B / O) / N)<br>如果B = 0.4， O = 2， N = 5， 计算变成下面这样：</p>
<p>Speedup = 1 / ( 0.4 / 2 + (1 - 0.4 / 2) / 5)<br>    = 1 / ( 0.2 + (1 - 0.4 / 2) / 5)<br>    = 1 / ( 0.2 + (1 - 0.2) / 5 )<br>    = 1 / ( 0.2 + 0.8 / 5 )<br>    = 1 / ( 0.2 + 0.16 )<br>    = 1 / 0.36<br>    = 2.77777 …<br>上面的计算结果可以看出，如果你通过一个因子2来优化不可并行化部分，一个因子5来并行化可并行化部分，这个程序或算法的最新优化版本最多可以比原来的版本快2.77777倍。</p>
<h2 id="测量，不要仅是计算"><a href="#测量，不要仅是计算" class="headerlink" title="测量，不要仅是计算"></a>测量，不要仅是计算</h2><p>虽然阿姆达尔定律允许你并行化一个算法的理论加速比，但是不要过度依赖这样的计算。在实际场景中，当你优化或并行化一个算法时，可以有很多的因子可以被考虑进来。</p>
<p>内存的速度，CPU缓存，磁盘，网卡等可能都是一个限制因子。如果一个算法的最新版本是并行化的，但是导致了大量的CPU缓存浪费，你可能不会再使用x N个CPU来获得x N的期望加速。如果你的内存总线（memory bus），磁盘，网卡或者网络连接都处于高负载状态，也是一样的情况。</p>
<p>我们的建议是，使用阿姆达尔定律定律来指导我们优化程序，而不是用来测量优化带来的实际加速比。记住，有时候一个高度串行化的算法胜过一个并行化的算法，因为串行化版本不需要进行协调管理（上下文切换），而且一个单个的CPU在底层硬件工作（CPU管道、CPU缓存等）上的一致性可能更好。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Interview/">Interview</a><a href="/tags/Java/">Java</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/08/22/java并发/" data-title="Java并发 | SamanthaChen&#39;s Blog" data-tsina="1544950963" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/08/24/java并发2/" title="Java并发编程实战--笔记">
  <strong>上一篇：</strong><br/>
  <span>
  Java并发编程实战--笔记</span>
</a>
</div>


<div class="next">
<a href="/2016/08/22/ThinkingInJava笔记7/"  title="Java编程思想-集合框架笔记">
 <strong>下一篇：</strong><br/> 
 <span>Java编程思想-集合框架笔记
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/08/22/java并发/" data-title="Java并发" data-url="http://yoursite.com/2016/08/22/java并发/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#多线程的优点和代价"><span class="toc-number">1.</span> <span class="toc-text">多线程的优点和代价</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发编程的模型"><span class="toc-number">2.</span> <span class="toc-text">并发编程的模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发模型与分布式系统之间的相似性"><span class="toc-number">2.1.</span> <span class="toc-text">并发模型与分布式系统之间的相似性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行工作者"><span class="toc-number">2.2.</span> <span class="toc-text">并行工作者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并行工作者模型的优点"><span class="toc-number">2.2.1.</span> <span class="toc-text">并行工作者模型的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行工作者模型的缺点"><span class="toc-number">2.2.2.</span> <span class="toc-text">并行工作者模型的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#共享状态可能会很复杂"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">共享状态可能会很复杂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无状态的工作者"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">无状态的工作者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#任务顺序是不确定的"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">任务顺序是不确定的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流水线模式"><span class="toc-number">2.3.</span> <span class="toc-text">流水线模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#反应器，事件驱动系统"><span class="toc-number">2.3.1.</span> <span class="toc-text">反应器，事件驱动系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Actors-和-Channels"><span class="toc-number">2.3.2.</span> <span class="toc-text">Actors 和 Channels</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流水线模型的优点"><span class="toc-number">2.3.3.</span> <span class="toc-text">流水线模型的优点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#无需共享的状态"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">无需共享的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有状态的工作者"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">有状态的工作者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hardware-Conformity"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">Hardware Conformity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#合理的作业顺序"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">合理的作业顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点"><span class="toc-number">2.3.3.5.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式并行（Functional-Parallelism）"><span class="toc-number">2.4.</span> <span class="toc-text">函数式并行（Functional Parallelism）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用那种并发模型最好？"><span class="toc-number">2.5.</span> <span class="toc-text">使用那种并发模型最好？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建并运行java线程"><span class="toc-number">3.</span> <span class="toc-text">创建并运行java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建Thread的子类"><span class="toc-number">3.1.</span> <span class="toc-text">创建Thread的子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现Runnable接口"><span class="toc-number">3.2.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建子类还是实现Runnable接口？"><span class="toc-number">3.3.</span> <span class="toc-text">创建子类还是实现Runnable接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见错误：调用run-方法而非start-方法"><span class="toc-number">3.4.</span> <span class="toc-text">常见错误：调用run()方法而非start()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程代码举例："><span class="toc-number">3.5.</span> <span class="toc-text">线程代码举例：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#竞态条件与临界区"><span class="toc-number">4.</span> <span class="toc-text">竞态条件与临界区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程安全与共享资源"><span class="toc-number">5.</span> <span class="toc-text">线程安全与共享资源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#局部变量"><span class="toc-number">5.1.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#局部的对象引用"><span class="toc-number">5.2.</span> <span class="toc-text">局部的对象引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象成员"><span class="toc-number">5.3.</span> <span class="toc-text">对象成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程控制逃逸规则"><span class="toc-number">5.4.</span> <span class="toc-text">线程控制逃逸规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程安全及不可变性"><span class="toc-number">6.</span> <span class="toc-text">线程安全及不可变性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java内存模型"><span class="toc-number">7.</span> <span class="toc-text">java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java内存模型和硬件内存架构之间的桥接"><span class="toc-number">7.1.</span> <span class="toc-text">Java内存模型和硬件内存架构之间的桥接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享对象可见性"><span class="toc-number">7.2.</span> <span class="toc-text">共享对象可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#竞态"><span class="toc-number">7.3.</span> <span class="toc-text">竞态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java同步块"><span class="toc-number">8.</span> <span class="toc-text">java同步块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-同步关键字（synchronized）"><span class="toc-number">8.1.</span> <span class="toc-text">Java 同步关键字（synchronized）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例方法同步"><span class="toc-number">8.2.</span> <span class="toc-text">实例方法同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态方法同步"><span class="toc-number">8.3.</span> <span class="toc-text">静态方法同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例方法中的同步块"><span class="toc-number">8.4.</span> <span class="toc-text">实例方法中的同步块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态方法中的同步块"><span class="toc-number">8.5.</span> <span class="toc-text">静态方法中的同步块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java同步实例"><span class="toc-number">8.6.</span> <span class="toc-text">Java同步实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程通信"><span class="toc-number">9.</span> <span class="toc-text">线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通过共享对象通信"><span class="toc-number">9.1.</span> <span class="toc-text">通过共享对象通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#忙等待-Busy-Wait"><span class="toc-number">9.2.</span> <span class="toc-text">忙等待(Busy Wait)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-notify-和notifyAll"><span class="toc-number">9.3.</span> <span class="toc-text">wait(),notify()和notifyAll()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#丢失的信号（Missed-Signals）"><span class="toc-number">9.4.</span> <span class="toc-text">丢失的信号（Missed Signals）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#假唤醒"><span class="toc-number">9.5.</span> <span class="toc-text">假唤醒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多个线程等待相同信号"><span class="toc-number">9.6.</span> <span class="toc-text">多个线程等待相同信号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-TheadLocal"><span class="toc-number">10.</span> <span class="toc-text">Java TheadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建一个ThreadLocal对象"><span class="toc-number">10.1.</span> <span class="toc-text">创建一个ThreadLocal对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问ThreadLocal对象"><span class="toc-number">10.2.</span> <span class="toc-text">访问ThreadLocal对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal泛型"><span class="toc-number">10.3.</span> <span class="toc-text">ThreadLocal泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化ThreadLocal"><span class="toc-number">10.4.</span> <span class="toc-text">初始化ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Full-ThreadLocal-Example"><span class="toc-number">10.5.</span> <span class="toc-text">Full ThreadLocal Example</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InheritableThreadLocal"><span class="toc-number">10.6.</span> <span class="toc-text">InheritableThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程通信（待补充）"><span class="toc-number">11.</span> <span class="toc-text">线程通信（待补充）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#死锁"><span class="toc-number">12.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#更复杂的死锁"><span class="toc-number">12.1.</span> <span class="toc-text">更复杂的死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库的死锁"><span class="toc-number">12.2.</span> <span class="toc-text">数据库的死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#避免死锁"><span class="toc-number">13.</span> <span class="toc-text">避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#加锁顺序"><span class="toc-number">13.1.</span> <span class="toc-text">加锁顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁时限"><span class="toc-number">13.2.</span> <span class="toc-text">锁时限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁检测"><span class="toc-number">13.3.</span> <span class="toc-text">死锁检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#饥饿和公平"><span class="toc-number">14.</span> <span class="toc-text">饥饿和公平</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#下面是本文讨论的主题："><span class="toc-number">14.1.</span> <span class="toc-text">下面是本文讨论的主题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中导致饥饿的原因"><span class="toc-number">14.2.</span> <span class="toc-text">Java中导致饥饿的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#高优先级线程吞噬所有的低优先级线程的CPU时间"><span class="toc-number">14.2.1.</span> <span class="toc-text">高优先级线程吞噬所有的低优先级线程的CPU时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程被永久堵塞在一个等待进入同步块的状态"><span class="toc-number">14.2.2.</span> <span class="toc-text">线程被永久堵塞在一个等待进入同步块的状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在Java中实现公平性"><span class="toc-number">14.3.</span> <span class="toc-text">在Java中实现公平性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用锁方式替代同步块"><span class="toc-number">14.3.1.</span> <span class="toc-text">使用锁方式替代同步块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公平锁"><span class="toc-number">14.3.2.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能考虑"><span class="toc-number">14.3.3.</span> <span class="toc-text">性能考虑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套管程锁死"><span class="toc-number">15.</span> <span class="toc-text">嵌套管程锁死</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个更现实的例子"><span class="toc-number">15.1.</span> <span class="toc-text">一个更现实的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#嵌套管程锁死-VS-死锁"><span class="toc-number">15.2.</span> <span class="toc-text">嵌套管程锁死 VS 死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Slipped-Conditions-未完"><span class="toc-number">16.</span> <span class="toc-text">Slipped Conditions(未完)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java中的锁"><span class="toc-number">17.</span> <span class="toc-text">java中的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个简单的锁"><span class="toc-number">17.1.</span> <span class="toc-text">一个简单的锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁的可重入性"><span class="toc-number">17.2.</span> <span class="toc-text">锁的可重入性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁的公平性"><span class="toc-number">17.3.</span> <span class="toc-text">锁的公平性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在finally语句中调用unlock"><span class="toc-number">17.4.</span> <span class="toc-text">在finally语句中调用unlock()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java中的读-写锁"><span class="toc-number">18.</span> <span class="toc-text">Java中的读/写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#读-写锁的Java实现"><span class="toc-number">18.1.</span> <span class="toc-text">读/写锁的Java实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读-写锁的重入"><span class="toc-number">18.2.</span> <span class="toc-text">读/写锁的重入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读锁重入"><span class="toc-number">18.3.</span> <span class="toc-text">读锁重入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写锁重入"><span class="toc-number">18.4.</span> <span class="toc-text">写锁重入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读锁升级到写锁"><span class="toc-number">18.5.</span> <span class="toc-text">读锁升级到写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写锁降级到读锁"><span class="toc-number">18.6.</span> <span class="toc-text">写锁降级到读锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可重入的ReadWriteLock的完整实现"><span class="toc-number">18.7.</span> <span class="toc-text">可重入的ReadWriteLock的完整实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在finally中调用unlock"><span class="toc-number">18.8.</span> <span class="toc-text">在finally中调用unlock()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重入锁死"><span class="toc-number">19.</span> <span class="toc-text">重入锁死</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#信号量"><span class="toc-number">20.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单的Semaphore实现"><span class="toc-number">20.1.</span> <span class="toc-text">简单的Semaphore实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Semaphore来产生信号"><span class="toc-number">20.2.</span> <span class="toc-text">使用Semaphore来产生信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可计数的Semaphore"><span class="toc-number">20.3.</span> <span class="toc-text">可计数的Semaphore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有上限的Semaphore"><span class="toc-number">20.4.</span> <span class="toc-text">有上限的Semaphore</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#阻塞队列"><span class="toc-number">21.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-number">21.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池"><span class="toc-number">22.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java并发编程之CAS"><span class="toc-number">23.</span> <span class="toc-text">Java并发编程之CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS的使用场景"><span class="toc-number">23.1.</span> <span class="toc-text">CAS的使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS用作原子操作"><span class="toc-number">23.2.</span> <span class="toc-text">CAS用作原子操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#同步器"><span class="toc-number">24.</span> <span class="toc-text">同步器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#状态"><span class="toc-number">24.1.</span> <span class="toc-text">状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问条件"><span class="toc-number">24.2.</span> <span class="toc-text">访问条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态变化"><span class="toc-number">24.3.</span> <span class="toc-text">状态变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通知策略"><span class="toc-number">24.4.</span> <span class="toc-text">通知策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Test-and-Set方法"><span class="toc-number">24.5.</span> <span class="toc-text">Test-and-Set方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set方法"><span class="toc-number">24.6.</span> <span class="toc-text">Set方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#非阻塞算法"><span class="toc-number">25.</span> <span class="toc-text">非阻塞算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞并发算法"><span class="toc-number">25.1.</span> <span class="toc-text">阻塞并发算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞并发算法-1"><span class="toc-number">25.2.</span> <span class="toc-text">阻塞并发算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非阻塞并发数据结构"><span class="toc-number">25.3.</span> <span class="toc-text">非阻塞并发数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于volatile变量更高级的数据结构"><span class="toc-number">25.3.1.</span> <span class="toc-text">基于volatile变量更高级的数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用CAS的乐观锁"><span class="toc-number">25.4.</span> <span class="toc-text">使用CAS的乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么称它为乐观锁"><span class="toc-number">25.4.1.</span> <span class="toc-text">为什么称它为乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#乐观锁是非阻塞的"><span class="toc-number">25.4.2.</span> <span class="toc-text">乐观锁是非阻塞的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不可替换的数据结构"><span class="toc-number">25.5.</span> <span class="toc-text">不可替换的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共享预期的修改"><span class="toc-number">25.5.1.</span> <span class="toc-text">共享预期的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可完成的预期修改"><span class="toc-number">25.5.2.</span> <span class="toc-text">可完成的预期修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-B-A问题"><span class="toc-number">25.5.3.</span> <span class="toc-text">A-B-A问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-B-A问题的解决方案"><span class="toc-number">25.5.4.</span> <span class="toc-text">A-B-A问题的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个非阻塞算法模板"><span class="toc-number">25.6.</span> <span class="toc-text">一个非阻塞算法模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非阻塞算法是不容易实现的"><span class="toc-number">25.7.</span> <span class="toc-text">非阻塞算法是不容易实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用非阻塞算法的好处"><span class="toc-number">25.8.</span> <span class="toc-text">使用非阻塞算法的好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#阿姆达定律"><span class="toc-number">26.</span> <span class="toc-text">阿姆达定律</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义"><span class="toc-number">26.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算例子"><span class="toc-number">26.2.</span> <span class="toc-text">计算例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图示"><span class="toc-number">26.3.</span> <span class="toc-text">图示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化算法"><span class="toc-number">26.4.</span> <span class="toc-text">优化算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化串行分量"><span class="toc-number">26.4.1.</span> <span class="toc-text">优化串行分量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时间-vs-加速"><span class="toc-number">26.5.</span> <span class="toc-text">运行时间 vs. 加速</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测量，不要仅是计算"><span class="toc-number">26.6.</span> <span class="toc-text">测量，不要仅是计算</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="SamanthaChen" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/Database/" title="Database">Database<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/DesignPattern/" title="DesignPattern">DesignPattern<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Interview/" title="Interview">Interview<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/JVM/" title="JVM">JVM<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>18</sup></a></li>
		  
		
		  
			<li><a href="/categories/MachineLearning/" title="MachineLearning">MachineLearning<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/Network/" title="Network">Network<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/OS/" title="OS">OS<sup>7</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Interview/" title="Interview">Interview<sup>41</sup></a></li>
			
		
			
				<li><a href="/tags/MachineLearning/" title="MachineLearning">MachineLearning<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Notes/" title="Notes">Notes<sup>23</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>18</sup></a></li>
			
		
			
				<li><a href="/tags/统计学习/" title="统计学习">统计学习<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Algorithm/" title="Algorithm">Algorithm<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/OS/" title="OS">OS<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Network/" title="Network">Network<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/LeetCode/" title="LeetCode">LeetCode<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Database/" title="Database">Database<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/DesignPattern/" title="DesignPattern">DesignPattern<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Concurrentcy/" title="Concurrentcy">Concurrentcy<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Test/" title="Test">Test<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NLP/" title="NLP">NLP<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1544950963&verifier=4d3c970d&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello World, 我叫陈希蔓. <br/>
			这是我的个人技术博客.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1544950963" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/SamanthaChen" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/chen-xi-man" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:chenximan@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="陈希蔓">陈希蔓</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"samanthachen"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4389501af9c71ed21cde31c63d94ebfd";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1259995191'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1259995191' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End --><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  </body>
</html>
